<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"/Users/cyapp/tmp/xml-dtd-4.4/docbookx.dtd">

<book>
  <bookinfo>
    <title>BRL-CAD Tutorial Series: Volume II - Introduction to MGED</title>
    <authorgroup>
      <author>
	<firstname>Lee</firstname>
	<surname>Butler</surname>
	<othername role='mi'>A</othername>
	<affiliation>
	  <shortaffil>ARL</shortaffil>
	  <orgname>Army Research Laboratory</orgname>
	  <orgdiv>Survivability/Lethality Analysis Directorate</orgdiv>
	  <address>
	    Aberdeen Proving Ground
	    <state>MD</state> 
	    <postcode>21005-5068</postcode>
	  </address>
	</affiliation>
      </author>
      <author>
	<firstname>Eric</firstname>
	<surname>Edwards</surname>
	<othername role='mi'>W</othername>
	<affiliation>
	  <shortaffil>SURVICE</shortaffil>
	  <orgname>SURVICE Engineering Company</orgname>
	  <address>
	    <street>4695 Millennium Drive</street>
	    <city>Belcamp</city>
	    <state>MD</state> 
	    <postcode>21017-1505</postcode>
	  </address>
	</affiliation>
      </author>
      <author>
	<firstname>Betty</firstname>
	<surname>Schueler</surname>
	<othername role='mi'>J</othername>
	<affiliation>
	  <shortaffil>QRI</shortaffil>
	  <orgname>Quantum Research International, Inc.</orgname>
	  <address>
	    <street>2014 Tollgate Rd, Suite 203</street>
	    <city>Bel Air</city>
	    <state>MD</state> 
	    <postcode>21014</postcode>
	  </address>
	</affiliation>
      </author>
      <author>
	<firstname>Robert</firstname>
	<surname>Parker</surname>
	<othername role='mi'>G</othername>
	<affiliation>
	  <shortaffil>ARL</shortaffil>
	  <orgname>Army Research Laboratory</orgname>
	  <orgdiv>Survivability/Lethality Analysis Directorate</orgdiv>
	  <address>
	    Aberdeen Proving Ground
	    <state>MD</state> 
	    <postcode>21005-5068</postcode>
	  </address>
	</affiliation>
      </author>
      <author>
	<firstname>John</firstname>
	<surname>Anderson</surname>
	<othername role='mi'>R</othername>
	<affiliation>
	  <shortaffil>ARL</shortaffil>
	  <orgname>Army Research Laboratory</orgname>
	  <orgdiv>Survivability/Lethality Analysis Directorate</orgdiv>
	  <address>
	    Aberdeen Proving Ground
	    <state>MD</state> 
	    <postcode>21005-5068</postcode>
	  </address>
	</affiliation>
      </author>
    </authorgroup>
    
    <publishername>Army Research Laboratory</publishername>
    <pubsnumber>ARL-SR-102</pubsnumber>
    <pubdate>April 2001</pubdate>
    
    <legalnotice>
      <para>Approved for public release; distribution is unlimited</para>
      
      <para>The findings in this report are not to be construed as an
      official Department of the Army position unless so designated 
      by other authorized documents.</para>
      
      <para>Citation of manufacturer's or trade names does not constitute
      an official endorsement or approval of the use thereof.</para>
      
      <para>Destroy this report when it is no longer needed. Do not return
      it to the originator.</para>
    </legalnotice>      
    
    <abstract>
      <para>
	Since 1979, the U.S. Army Research Laboratory has been developing and
	distributing the BRL-CAD constructive solid geometry (CSG) modeling
	package for a wide range of military and industrial applications. The
	package includes a large collection of tools and utilities including an
	interactive geometry editor, ray-tracing and generic framebuffer
	libraries, a network-distributed image-processing and signal-processing
	capability, and an embedded scripting language.
      </para>
      
      <para>
	As part of this effort, a multivolume tutorial series is being developed
	to assist users in the many features of the BRL-CAD package. The
	"Introduction to MGED," which is the second volume in the series, is
	intended to provide new users with a basic understanding of the
	Multi-Device Geometry Editor (MGED), which is the heart of BRL-CAD. Other
	volumes focus on installation procedures, advanced features, and
	programming.
      </para>
    </abstract>
  </bookinfo>

  <preface>
    <title>Preface</title>
    <para>
      Since 1979, the U.S. Army Research Laboratory (formerly the Ballistic
      Research Laboratory) has been developing the BRL-CAD constructive solid
      geometry (CSG) modeling package for a wide range of military and
      industrial applications. The strength of the package lies in its ability
      to build realistic models of complex objects from a relatively small set
      of "primitive shapes" by employing the basic Boolean operations of union,
      subtraction, and intersection and by assigning real-world material
      attributes.
    </para>
    
    <para>
      The package comprises a large collection of tools, utilities, and
      libraries including an interactive geometry editor, ray-tracing and
      generic framebuffer libraries, a network-distributed image-processing and
      signal-processing capability, and an embedded scripting language.
    </para>
    
    <para>
      Although BRL-CAD has continued to mature in performance and utility,
      developers have strived to keep the package approachable and easy to use,
      as evidenced by the package's dual command formats, its newly renovated
      graphical user interface (GUI), and its customization potential through
      user scripting.
    </para>
    
    <para>
      In addition, a multivolume tutorial series is being developed to assist
      users in a variety of BRL-CAD areas and applications. The "Introduction to
      MGED," which is the second volume in the series, is intended to provide
      new users with a basic understanding of the Multi-Device Geometry Editor
      (MGED), which is the heart of the BRL-CAD package. Other volumes focus on
      installation procedures, advanced features, and programming.
    </para>
  </preface>
  
  <preface>
    <title>Acknowledgements</title>
    <para>
      The authors would like to thank Paul Tanenbaum, TraNese Christy, Sean
      Morrison, and the other members of the Advanced Computer Systems Team who
      reviewed this document in a timely manner and made many helpful
      suggestions to improve its accuracy and presentation.
    </para>
    
    <para>
      In addition, the authors would like to acknowledge team member Mike Muuss,
      who passed away while this volume was in preparation. Mike was the
      original architect of the BRL-CAD package and guided its development for
      20 years until his death on 20 November 2000. He embodied a unique blend
      of unparalleled intellect, unquenchable curiosity, and unending energy to
      advance the capabilities of everything and everyone he touched. A
      natural-born troubleshooter, Mike approached every job, big or small, with
      a passion for excellence and a child-like enthusiasm, which helped drive
      BRL-CAD far beyond expectations.
    </para>
    
    <para>
      Although he never got a chance to review this document, much of this work
      is a result of his vision and attention to detail. Therefore, the BRL-CAD
      Tutorial Series is dedicated to his memory. His sharp mind, his warm
      spirit, and his loyal friendship will be greatly missed.
    </para>
  </preface>

  <chapter id="Lesson-1">
    <title>Creating Primitive Shapes</title>
    
    <para>
      In this lesson, you will:
      
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Launch the MGED program.</para>
	</listitem>
	<listitem>
	  <para>Enter commands at the MGED prompt in the Command Window.</para>
	</listitem>
	<listitem>
	  <para>Use the MGED Graphical User Interface (GUI).</para>
	</listitem>
	<listitem>
	  <para>Open or create a new database when launching MGED.</para>
	</listitem>
	<listitem>
	  <para>Use the GUI to open or create a new database.</para>
	</listitem>
	<listitem>
	  <para>Title a database.</para>
	</listitem>
	<listitem>
	  <para>Select a unit of length for your design.</para>
	</listitem>
	<listitem>
	  <para>Select a primitive shape.</para>
	</listitem>
	<listitem>
	  <para>Create a primitive shape using the make command.</para>
	</listitem>
	<listitem>
	  <para>Use the Z command to clear the Graphics Window.</para>
	</listitem>
	<listitem>
	  <para>Draw a previously created shape using the draw command.</para>
	</listitem>
	<listitem>
	  <para>Use the erase command to delete an item in the Graphics Window display.</para>
	</listitem>
	<listitem>
	  <para>Create a sphere using the GUI menu.</para>
	</listitem>
	<listitem>
	  <para>Use the l command to list a shape's attributes or parameters.</para>
	</listitem>
	<listitem>
	  <para>Use the ls command to list the contents of the database.</para>
	</listitem>
	<listitem>
	  <para>Eliminate a shape or object from the database using the kill command.</para>
	</listitem>
	<listitem>
	  <para>Edit a command.</para>
	</listitem>
	<listitem>
	  <para>Use the q or exit commands to quit the program.</para>
	</listitem>
      </itemizedlist>  
    </para>
    
    <sect1>
      <title>Launching the MGED Program</title> 

      <para>
	To launch the MGED program, type mged at the Terminal (tty) prompt and
	then press the ENTER key. This brings up two main windows: the MGED
	Command Window and the MGED Graphics Window (sometimes called the Geometry
	Window). Both windows will initially be blank, awaiting input from you. To
	leave the program at any time, at the Command Line type either the letter
	q or the word quit and then press the ENTER key.
      </para>


    </sect1>
    <sect1>
      <title>Entering Commands in the Command Window</title> 
      
      <para>
	You can type in commands at the mged> prompt. Many experienced UNIX users
	prefer this method because it allows them to quickly create a model (which
	we sometimes refer to as a "design") without having to point and click on
	a lot of options. The complete listing of editing commands and what they
	do can be found in Appendix A.
      </para>
      
      <caution>
	<para>
	  Check all typed entries before you press the ENTER key. If you find   
	  you made a mistake, simply press the BACKSPACE key until you have     
	  erased over the mistake and then re-type the information. Later you   
	  will get more experience editing text using vi and emacs command      
	  emulation.
	</para>
      </caution>
      
    </sect1>
    
    <sect1>
      <title>Using the GUI</title>
      
      <para>
	Users who are more familiar with Microsoft Windows may prefer to use the
	GUI pull-down menus at the top of the Command or Graphics Window (they are
	the same in either window). The menus are divided into logical groupings
	to help you navigate through the MGED program.
      </para>
      
      <para>
	Before you can create a model, you need to open a new database either
	through the Terminal Window when starting MGED or through the GUI after
	starting MGED.
      </para>
    </sect1>
   
    <sect1>
      <title>Opening or Creating a New Database when Launching MGED</title>
    
      <para>
	When launching MGED, you can open or create a database at the same time.
	At the shell prompt (usually a $ or %), in the Terminal Window, type mged
	followed by a new or existing database name with a .g extension. For
	example:
	
	<command>mged sphere.g[ENTER]</command>
	
	<figure>
	  <title>Terminal Window</title>
	  <screenshot>
	    <graphic fileref="terminal.png"></graphic>
	  </screenshot>
	</figure>
	
	If you are creating a new database, a small dialog box asking if you want
	to create a new database named sphere.g will appear. Click on Yes, and a
	new database will be created. If sphere.g already exists, MGED will open
	the sphere.g database as the program is launched.
      </para>
    </sect1> 

    <sect1>
      <title>Using the GUI to Open or Create a Database</title>
  
      <para>
	Alternatively, once you have launched MGED, you can open an existing
	database or create a new database using the GUI menus (at the top of the
	Command or Graphics Window) by clicking on File and then either Open or
	New. Both options bring up a small dialog box. The Open dialog box will
	ask you to type in the name of an existing database. The New dialog box
	will ask you to type in the name of a new database. Click on OK to accept
	the database.
      </para>
      
      <para>
	For this lesson, create a new database called sphere.g. To do this, type
	sphere.g at the end of the path name, as shown in the following
	illustration. Click on OK to accept the database name.
	
	<figure>
	  <title>MGED Command Window with Database Dialog Box</title>
	  <screenshot>
	    <graphic fileref="commandwindow.png"></graphic>
	  </screenshot>
	</figure>
	
	<figure>
	  <title>MGED Graphics Window</title>
	  <screenshot>
	    <graphic fileref="graphicswindow.png"></graphic>
	  </screenshot>
	</figure>
	
	One advantage to using the GUI, if you aren't familiar with UNIX file
	management, is that this will show you your current path name, so you will
	know exactly where your database is going to be located. This can be
	especially helpful if you have a lot of directories or files to manage.
      </para>  
    </sect1>

    <sect1>
      <title>Assigning a Title to Your Database</title>

      <para>
	You can title your new database to provide an audit trail for you or
	others who might use your database. After the prompt, in the Command
	Window, type title followed by a space and a name that reflects the
	database you are going to make. When you are done, press the ENTER key.
	For example:

	<command>mged> title MySphere[ENTER]</command>
	
	Note that in BRL-CAD versions prior to release 6.0, the title is limited
	to 72 characters.
      </para>  
    </sect1>
    
    <sect1>
      <title>Selecting a Unit of Length</title>
      
      <para>
	MGED uses millimeters for all internal mathematical processes; however,
	you can create your design using some other unit, such as feet. For this
	lesson, inches is used. To select inches, move your mouse pointer to the
	File menu at the top of the Command Window. Click on File and then
	Preferences. A new menu will appear. Select Units and then Inches. If you
	are not a "point-and-click" type of person and prefer a Command Line, then
	just type units in after the MGED prompt in the Command Window, followed
	by the ENTER key. The Command Line looks like:
	
	<command>mged> units in[ENTER]</command>
      </para>  
    </sect1>

    <sect1>
      <title>Selecting a Primitive Shape</title>
      
      <para>
	MGED provides a variety of primitive shapes (sometimes referred to as
	simply shapes or primitives) that you can use to build models. Each type
	of shape has parameters that define its position, orientation, and size. A
	listing of these shapes and their respective parameters is given in
	Appendix C.
      </para>
      
      <note>
	<para>
	  Historically, the word solid was used for what we now refer to as a   
	  primitive shape. This older terminology was sometimes difficult for   
	  new users to understand. If you see the word solid used in any        
	  BRL-CAD programs, documentation, or commands (e.g., in Appendix A),   
	  think primitive shape.  
	</para>
      </note>  
    </sect1>

    <sect1>
      <title>Creating a Sphere from the Command Line</title>

      <para>
	For this lesson, you are going to create a single sphere. There are two
	ways you can create a primitive shape. You can create all shapes through
	the Command Window and most shapes through the GUI.
      </para>
      
      <para>
	You can easily create a sphere from the prompt in the Command Window by
	typing just a few commands. At the MGED prompt, type:
	
	<command>make sph1.s sph[ENTER]  [Note: Use the digit 1, not the letter l] </command>

      </para>
      
      <para>
	This command tells the MGED program to:
	
	<informaltable frame="all">
	  <tgroup cols='3'>
	    <tbody>
	      <row><entry>make</entry><entry>sph1.s</entry><entry>sph</entry></row>
	      <row><entry>Make a primitive shape</entry><entry>Name it sph1.s</entry>
	           <entry>Make the shape a sphere</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

      </para>

      <para>
	A default sphere will be created, and a wireframe representation of the
	primitive shape will appear in the Graphics Window. In Lesson 4, you will
	give your sphere a solid, three-dimensional look.
      </para>
      
      <para>
	This command will draw the primitive shape in the Graphics Window.
      </para>
    </sect1>

    <sect1>
      <title>Clearing the Graphics Window</title>
      
      <para>
	To build another object or work on another primitive shape, you can easily
	clear the Graphics Window through the Command Window. At the Command Line
	prompt, type an uppercase Z (for zap) followed by ENTER.
      </para>
      
      <note>
	<para>
	  Before using the zap option, make sure you "activate" (i.e.,    
	  set the focus on) the Command Window. If you type a z and your cursor 
	  is still in the Graphics Window, you will send your design spinning.  
	  Typing a zero (0) will stop the spin.
	</para>
      </note>
    </sect1> 
    
    <sect1>
      <title>Drawing a Previously Created Object</title>
      
      <para>
	To recall the sphere, type the command on the Command Line as follows:
	
	<command>draw sph1.s[ENTER]</command>
	
	This command tells the MGED program to:
	
	<informaltable frame="all">
	  <tgroup cols='2'>
	    <tbody>
	      <row><entry>draw</entry><entry>sph1.s</entry></row>
	      <row><entry>Draw a previously created primitive shape</entry>
	           <entry>named sph1.s</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
    </sect1> 
    
    <sect1>
      <title>Erasing an Item from the Graphics Window</title>
      
      <para>
	You may occasionally want to erase a particular item from the display in
	the Graphics Window. You can use the erase command to remove the item
	without any file operation being performed; the item remains in the
	database. To delete the sph1.s object from the display, at the Command
	Window prompt, type:
	
	<command>erase sph1.s[ENTER]</command>
      </para>
    </sect1>     

    <sect1>
      <title>Creating a Sphere Using the GUI</title>
      
      <para>
	Another way to create a sphere is to use the GUI menu system duplicated at
	the top of the Command and Graphics windows. Clear your Graphics Window by
	using the previously described Z command. Then, in the Graphics Window,
	click on Create, and a drop-down menu will appear with the various
	primitive shape types available. Select sph (for sphere) under the
	Ellipsoids category. This will bring up a dialog box. Click in the empty
	text box and type sph2.s. Click on Apply  or press ENTER. A new sphere
	will be created and drawn in the Graphics Window. When you create a shape
	through the GUI, the shape will automatically be in edit mode so that you
	can change it as needed, and the shape's parameters-which define its
	position, orientation, and size-will be in view.
      </para>
    </sect1>

    <sect1>
      <title>Viewing a Shape's Parameters</title>

      <para>
	Sometimes when you are making a model, you might want to view a shape's
	parameters, such as height, width, or radius, in the Command Window. You
	can easily list the attributes of a shape by typing the l (for "list")
	command at the Command Window prompt as follows:
	
	<command>l shape_name[ENTER]</command> 
	<note><para>[Note: The command is the lowercase letter l]</para></note>
      </para>
      
      <note>
	<para>
	  Note: If you attempt to type in the Command Window and you see no     
	  words appearing there, chances are the focus has not been set on that 
	  window (i.e., keyboard input is still directed to another window).    
	  Depending on your system's configurations, the focus is set to a      
	  window either by moving the cursor into the window or clicking on the 
	  window.                           
	</para>
      </note>
      
      <para>
	An example of the dialog that might occur in the Command Window for the
	parameters or attributes of the first sphere you created is as follows:
	
	<literallayout>
      mged> l sph1.s

      sph1.s: ellipsoid (ELL)

      V (1, 1, 1)

      A (1, 0, 0) mag=1

      B (0, 1, 0) mag=1

      C (0, 0, 1) mag=1

      A direction cosines=(0, 90, 90)

      A rotation angle=0, fallback angle=0

      B direction cosines=(90, 0, 90)

      B rotation angle=90 fallback angle=0

      C direction cosines=(90, 90, 0)

      C rotation angle=0, fallback angle=90
	</literallayout>
      </para>

      <para>
	Don't be concerned if you notice in the preceding output that MGED stores
	your sphere as an ellipsoid. In actuality, the sphere is just a special
	case of the ellipsoid (see Appendix C). Also, note that it is not
	important if the numbers in your output do not match what is shown in this
	example.
      </para>
      
      <para>
	Use the l command to list both sph1.s and sph2.s before continuing with
	this lesson.
      </para>
      
    </sect1>

    <sect1>
      <title>Listing the Contents of a Database</title>

      <para>
	In addition to viewing a shape's contents, you might also want to list the
	contents of the database to see what items have been created. To view the
	database contents, type at the Command Window prompt:
	
	<command>ls[ENTER]</command>
      </para>
    </sect1>

    <sect1>
      <title>Killing a Shape or Object</title>
      
      <para>
	Sometimes when creating a model, you may need to eliminate a shape or
	object from the database. The kill command is used to do this. For
	example, if you wanted to kill the sph1.s shape, you would type at the
	Command Window prompt:
	
	<command>kill sph1.s[ENTER]</command>
	
	Make another sphere through either the Command Window or the GUI and name
	it sph3.s. Once the sphere is made, use the kill command to eliminate it
	from the database by typing at the Command Window prompt:
	
	<command>kill sph3.s[ENTER]</command>
	
	You can tell the shape has been eliminated by using the ls command in the
	Command Window to list the contents of the database. At the Command Window
	prompt, type:
	
	<command>ls[ENTER]</command>
	
	You should see two shapes listed: sph1.s and sph2.s.
      </para>

      <note>
	<para>
	  Note: All changes are immediately applied to the database, so there   
	  is no "save" or "save as" command. Likewise, there is presently no    
	  "undo" command to bring back what you have deleted, so be sure you    
	  really want to permanently delete data before using the kill command. 
	</para>
      </note>
    </sect1>

    <sect1>
      <title>Editing Commands in the Command Window</title>
      
      <para>
	Occasionally, when you enter commands in the Command Window, you will make
	a mistake in typing. MGED can emulate either the emacs or vi syntax for
	Command Line editing. By default, the emacs syntax is used. See Appendix B
	for a list of keystrokes, effects, and ways to select between the two
	command sets.
      </para>
      
      <para>
	You can also use the arrow keys to edit commands. The left and right arrow
	keys move the cursor in the current Command Line. Typing ENTER at any
	location on the Command Line executes the command. Note that both the
	BACKSPACE and DELETE keys will delete one character to the left of the
	cursor.
      </para>
      
      <para>
	MGED keeps a history of commands that have been entered. The up and down
	arrow keys allow you to select a previously executed command for editing
	and re-execution.
      </para>  
    </sect1>
    
    <sect1>
      <title>Quitting MGED</title>
      
      <para>
	Remember, to leave the program at any time, type from the Command Line
	either the letter q or the word quit and then press the ENTER key. You may
	also quit the program by selecting Exit from the File menu.
      </para>  
    </sect1>
    
    <sect1>
      <title>Review</title>
      
      <para>
	In this lesson, you:
	
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Started the MGED program.</para>
	  </listitem>
	  <listitem>
	    <para>Entered commands in the Command Window.</para>
	  </listitem>
	  <listitem>
	    <para>Used the MGED GUI.</para>
	  </listitem>
	  <listitem>
	    <para>Created or opened a database using MGED naming conventions.</para>
	  </listitem>
	  <listitem>
	    <para>Used the GUI to create or open a database.</para>
	  </listitem>
	  <listitem>
	    <para>Titled a database.</para>
	  </listitem>
	  <listitem>
	    <para>Selected a unit of measure for a design.</para>
	  </listitem>
	  <listitem>
	    <para>Selected a primitive shape.</para>
	  </listitem>
	  <listitem>
	    <para>Created a primitive shape using the make command in the Command Window.</para>
	  </listitem>
	  <listitem>
	    <para>Cleared the screen of a design using the Z command.</para>
	  </listitem>
	  <listitem>
	    <para>Drew a previously created shape using the draw command.</para>
	  </listitem>
	  <listitem>
	    <para>Used the erase command to delete a shape from the Graphics Window display.</para>
	  </listitem>
	  <listitem>
	    <para>Used the GUI to create a primitive shape.</para>
	  </listitem>
	  <listitem>
	    <para>Used the l command to view a shape's parameters.</para>
	  </listitem>
	  <listitem>
	    <para>Used the ls command to list the contents of the database.</para>
	  </listitem>
	  <listitem>
	    <para>Used the kill command to eliminate a shape from the database.</para>
	  </listitem>
	  <listitem>
	    <para>Edited commands in the Command Window.</para>
	  </listitem>
	  <listitem>
	    <para>Used the q or Exit commands to quit the program.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter> 

  <chapter id="Lesson-2">
    <title>Learning the Viewing Options</title>
    
    <para>
      In this lesson, you will:
      
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Create a model radio.</para>
	</listitem> 
	<listitem>
	  <para>Locate  viewing information in the Command Window.</para>
	</listitem> 
	<listitem>
	  <para>Identify elements of the MGED viewing system.</para>
	</listitem> 
	<listitem>
	  <para>View your radio from different angles.</para>
	</listitem> 
	<listitem>
	  <para>Work with Shift Grips.</para>
	</listitem> 
      </itemizedlist>
    </para>
    
    <para>
      Models in BRL-CAD are constructed in a single xyz coordinate system, which
      we sometimes refer to as model space. The Graphics Window of MGED displays
      a portion of this space. The xyz coordinate system is used for specifying
      both the geometry and the view of the geometry that is presented in the
      Graphics Window.
    </para>
    
    <para>
      MGED offers a default view and a variety of optional views. You can switch
      back and forth between these views during and after model creation. This
      lesson is designed to help you understand the viewing process and options.
    </para>
    
    <sect1>
      <title>Creating a Radio</title>
     
      <para>
	To gain practice viewing actual geometry, let's build a simple geometric
	object-a "walkie-talkie" radio. Note that the commands we use to do this
	are not discussed here because our current concern is on applying the
	principles of viewing. Later lessons on creating geometry address these
	commands in detail. Begin by launching MGED and creating a new database
	named radio.g. Remember that one way to do this is to type the following
	command in a Terminal Window:
	
	<command>$ mged radio.g</command>
      </para>
      
      <para>
	Type the following in the Command Window, carefully checking each line
	before pressing ENTER. If you make a mistake, use BACKSPACE or the left/
	right arrow keys to make corrections before pressing ENTER (see Appendix B
	for the editing command list).
      </para>
      
      <note>
	<para>
       Be especially careful to note the difference between the numeral one  
       [1] and the letter l [l] in ell1 on the third line.
	</para>
      </note>
      
      <literallayout>
       in body.s rpp 0 16 0 32 0 48[ENTER]
       
       in btn.s rec 8 30 36 0 3 0 4 0 0 0 0 2[ENTER]
       
       in btn2.s ell1 8 33 36 4 0 0 2[ENTER]
       
       in spkr.s tor 16 16 16 1 0 0 12 1[ENTER]
       
       in ant.s rcc 2 2 46 0 0 48 1[ENTER]
       
       in knob.s rcc 4 4 40 8 0 0 5[ENTER]
      </literallayout>
      
      
      <note>
	<para>
	  Note that in the preceding Command Line expressions, btn is an        
	  abbreviation for button, ant is an abbreviation for antenna, and spkr 
	  is an abbreviation for speaker. Also note that the numbers could have 
	  been separated by single spaces. The extra spaces were inserted       
	  simply to improve readability. For some usages (e.g., the r and comb  
	  commands, which are discussed later), the number of spaces has to be  
	  exact.                   
	</para>
      </note>

      <para>
	An image similar to the following should now appear in the Graphics
	Window.
	
	<figure>
	  <title> Default View of a Radio</title>
	  <screenshot>
	    <graphic fileref="defaultradio.png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    
    <sect1>
      <title>Locating Viewing Information in the Command Window</title>
      <para>
	Now take a minute to look at the Command Window. Even if nothing is in the
	window, enclosed in the bottom border is a string of information about the
	Graphics Window. An example string might read:
	
	<literal>cent=(8.000 16.000 24.000) sz=96.000 mm az=35.00 el=25.00 tw=-0.00
	ang=(0.00 0.00 0.00)</literal>
      </para>
      <para>
	As detailed in the following table, this information contains four groups
	of viewing data about the Graphics Window.
	
	<table frame='all'><title>Viewing Data at the Bottom of the Command Window</title>
	<tgroup cols='5' align='center' colsep='1' rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	  <colspec colname='c3'/>
	  <colspec colname='c4'/>
	  <colspec colname='c5'/>
	  <thead>
	    <row>
	      <entry>Screen Designation</entry>
	      <entry>Viewing Information</entry>
	      <entry>Location of Variables</entry>
	      <entry>Default Units</entry>
	      <entry>Default Values</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>cent=</entry>
	      <entry>Center of View</entry>
	      <entry>First 3 numbers</entry>
	      <entry>Millimeters</entry>
	      <entry>0.000 0.000 0.000</entry>
	    </row>
	    <row>
	      <entry>sz=</entry>
	      <entry>Size of View</entry>
	      <entry>4th number</entry>
	      <entry>Millimeters</entry>
	      <entry>Dependent upon size selected</entry>
	    </row>
	    <row>
	      <entry>az=</entry>
	      <entry morerows='1' valign='middle'>Viewing Angle</entry>
	      <entry morerows='1' valign='middle'>5th and 6th numbers</entry>
	      <entry morerows='1' valign='middle'>Degrees</entry>
	      <entry>35.00</entry>
	    </row>
	    <row>
	      <entry>el=</entry>
	      <entry>25.00</entry>
	    </row>
	    <row>
	      <entry>tw=</entry>
	      <entry>Twist</entry>
	      <entry morerows='1' valign='middle'>7th-10th numbers</entry>
	      <entry morerows='1' valign='middle'>Degrees</entry>
	      <entry>0.00</entry>
	    </row>
	    <row>
	      <entry>ang=</entry>
	      <entry>Angle of View</entry>
	      <entry>0.00 0.00 0.00</entry>
	    </row>
	  </tbody>
	</tgroup>
	</table>
      </para>
    </sect1>
     
    <sect1>
      <title>Identifying Elements of the MGED Viewing System</title>
     
      <sect2>
	<title>Center of View</title>
	<para>
	  The first set of information tells you the center of what you are viewing.
	  You can change the center of where you are looking through both the GUI
	  and the Command Window.
	</para>
	<para>
	  To change the center of your view of the radio using the GUI, press the
	  SHIFT key and any mouse button while dragging the mouse. (This is an
	  example of a Shift Grip, which is described later in this chapter.) You
	  can also change the center of view by placing the mouse pointer where you
	  want the center to be and clicking the middle mouse button.
	</para>
	<para>
	  To change the center of view using the Command Window, simply type at the
	  prompt the word center followed by three values for x, y, and z  (which is
	  the 3-D coordinate system mentioned previously). For example:
	  
	  <command>center 0 15 325.735[Enter]</command>
	  
	  As you change your view of the geometry, notice that the numbers in the
	  brackets after the cent= title will change to reflect the new center of
	  the view.
	</para>
      </sect2>
      
      <sect2>
	<title>Size of View</title>
     
	<para>
	  The size of the view is the amount of model space that is shown in the
	  Graphics Window. For example, consider using a camera with a zoom lens to
	  photograph a rose. As shown in the following figures, if you zoom in on
	  the rose, it will appear large in relation to your viewing field. If you
	  zoom out, it will appear smaller. In actuality, the view size for the rose
	  image on the left might represent only 15 mm across while the view size
	  for the image on the right might represent 100 mm across. In both cases,
	  however, the actual size of the rose is the same.
	</para>
	
	<informaltable>
	  <tgroup cols='2'>
	    <tbody>
	      <row>
		<entry><graphic/></entry>
		<entry><graphic/></entry>
	      </row>
	      <row>
		<entry>Zoom In to View Details (small size of view)</entry>
		<entry>Zoom Out to View Object 
		in Relation to Environment (large size of view)</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
	
	<para>
	  To change the view size of your radio through the GUI, click the right
	  mouse button to zoom in and the left mouse button to zoom out. Each time
	  you click the left or right mouse button, the view of the design will
	  increase or decrease in size by a factor of 2 (i.e., two times larger or
	  two times smaller than the previous size).
	</para>
	<para>
	  You can also zoom in or out on your design by going to the View menu and
	  selecting Zoom In or Zoom Out. A drawback to this method is that you can
	  only zoom in or out one time because the drop-down menu closes once you
	  make a selection.
	</para>
	<para>
	  If you get lost at any point while creating a model, you can use the zap
	  (Z) command to clear the geometry from the Graphics Window and then recall
	  the shape with the draw command. When drawing in an empty Graphics Window,
	  MGED automatically sizes the view to fit what you draw into the window.
	</para>
	<para>
	  You can control the view size of your radio more accurately with the
	  Command Window. To set the size to 100 (of whichever units you have
	  selected), type at the prompt:
	  
	  <command>size 100[Enter]</command>
	</para>
	<para>
	  You can also zoom in or out on a design by typing zoom on the Command
	  Line. To make your radio appear 50% smaller, you would type:
	  
	  <command>zoom 0.5[Enter]</command>
	</para>
	<para>
	  To make your radio appear twice as large, you would type:
	  
	  <command>zoom 2[Enter]</command>
	</para>
	
	<note>
	  <para>
	    Remember that changing the view size does NOT affect the size of the
	    object. You will change the size of an object in Lesson 6.
	  </para>
	</note>
      </sect2>
      
      <sect2>
	<title>Angle of View</title>
	
	<para>
	  Azimuth, elevation, and twist (all measured in degrees) determine where
	  you are in relation to the object you are viewing. Azimuth determines
	  where you are around the sides of it (i.e., to the front, left, right,
	  behind, or somewhere in between), elevation determines where you are above
	  or below it, and twist determines the angle you are rotated about the
	  viewing direction.
	</para>
	<para>
	  To better understand azimuth, imagine walking around a truck with a camera
	  to photograph it. As shown in the following illustrations, you would be at
	  0'0 azimuth if you stood directly in front of the truck to take its
	  picture. If you circled around slightly to your right, you would be at
	  35'0 azimuth. If you moved further around until you were looking directly
	  at the driver's side (in U.S. trucks), you would be at 90'0 azimuth.
	  Standing behind it would put you at 180'0 azimuth. If you were facing the
	  passenger's side, you would be at 270'0 azimuth.
	</para>
	
	<note>
	  <para>
	    The terms azimuth, elevation, and twist are similar to the terms yaw,
	    pitch, and roll, respectively, which are common terms in the
	    aerospace industry.
	  </para>
	</note>
	
	
	<informaltable frame="none">
	  <tgroup cols='2'>
	    <tbody>
	      <row>
		<entry><graphic/></entry>
		<entry><graphic/></entry>
	      </row>
	      <row>
		<entry>Front (az=0, el=0)</entry>
		<entry>az=35, el=0</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
	
	<informaltable frame="none">
	  <tgroup cols='2'>
	    <tbody>
	      <row>
		<entry><graphic/></entry>
		<entry><graphic/></entry>
	      </row>
	      <row>
		<entry>Left (az=90, el=0)</entry>
		<entry>Rear (az=180, el=0)</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
	
	<informaltable frame="none">
	  <tgroup cols='1'>
	    <tbody>
	      <row>
		<entry><graphic/></entry>
	      </row>
	      <row>
		<entry>Right (az=270, el=0)</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
	
	<para>
	  Elevation, on the other hand, involves the viewer's position above or
	  below an object. In the preceding example, you circled around a truck
	  without changing your relative height. You had an elevation of 0'0, which
	  means you were level with it. As the following figures illustrate,
	  however, imagine stopping at the 35'0 azimuth position and then climbing a
	  ladder to photograph the truck from 25'0 elevation. Climbing higher, you
	  would be at 60'0 elevation. If you were directly above it with the camera
	  facing down, you would be at 90'0 elevation. If you crawled under the
	  truck and looked directly up at it, you would be at -90'0 elevation.
	</para>
	
	<informaltable frame="none">
	  <tgroup cols='2'>
	    <tbody>
	      <row>
		<entry><graphic/></entry>
		<entry><graphic/></entry>
	      </row>
	      <row>
		<entry>az=35, el=0</entry>
		<entry>az=35, el=25</entry>
	      </row>
	      <row>
		<entry><graphic/></entry>
		<entry><graphic/></entry>
	      </row>
	      <row>
		<entry>az=35, el=60</entry>
		<entry>az=35, el=90</entry>
	      </row>
	      <row>
		<entry><graphic/></entry>
		<entry><graphic/></entry>
	      </row>
	      <row>
		<entry>Top (az=270, el=90)</entry>
		<entry>Bottom (az=270, el=-90)</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
	
	<para>
	  Finally, twist (which is an optional setting in MGED) specifies a rotation
	  about the viewing direction. This rotation is applied to the view after
	  azimuth and elevation have been designated. So, returning to our truck
	  example, imagine standing in front of the vehicle (az=0, el=0) and then
	  tilting your camera counterclockwise 14'0. This would give your view a
	  14'0 twist angle, as shown in the following figure (on the left). Note
	  again that it is not the truck that is tipped up, but simply your view of
	  it. For more information on specifying twist, see the <command>ae</command> command in
	  Appendix A.
	  
	  <informaltable frame="none">
	    <tgroup cols='1'>
	      <tbody>
		<row>
		  <entry><graphic/></entry>
		</row>
		<row>
		  <entry>Front (az=0, el=0, tw=14)</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	</para>
      </sect2>
    </sect1>
    
    <sect1>
      <title>Summing up on Azimuth and Elevation and the xyz Coordinate System</title>
     
      <para>
	As mentioned at the start of this lesson, MGED operates in a
	three-dimensional coordinate system (determined by the x, y, and z axes).
	Azimuth is measured in the xy plane with the positive x direction
	corresponding to an azimuth of 0'0. Positive azimuth angles are measured
	from the positive x axis toward and past the positive y axis. Negative
	azimuth angles are measured in the other direction.
      </para>
      
      <figure>
	<title>Azimuth, Elevation, and the xyz Coordinate System</title>
	<screenshot>
	  <graphic fileref="coordsystem.png"/>
	</screenshot>
      </figure>
      
      <para>
	If the azimuth angle is 0, then elevation is measured in the xz plane with
	+90'0 corresponding to the positive z direction and -90'0 corresponding to
	the negative z direction. However, if azimuth is not 0, these angles are
	in a plane aligned with the azimuth direction.
      </para>
    </sect1>
    
    <sect1>
      <title>Viewing Your Radio from Different Angles</title>
      
      <para>
	Let's now experiment with different views of your radio. MGED has several
	standard default views, which you've already seen in the preceding truck
	example. They include Top (az270, el90); Bottom (az270, el-90); Right
	(az270, el0); Left (az90, el0); Front (az0, el0); Rear (az180, el0); az35,
	el25; and az45, el45.
      </para>
      
      <para>
	Go to the View menu and try viewing your radio from different angles.
      </para>
      
      <informaltable frame="none">
	<tgroup cols='2'>
	  <tbody>
	    <row>
	      <entry><graphic/></entry>
	      <entry><graphic/></entry>
	    </row>
	    <row>
	      <entry>Top</entry>
	      <entry>az35,el25</entry>
	    </row>
	    <row>
	      <entry><graphic/></entry>
	      <entry><graphic/></entry>
	    </row>
	    <row>
	      <entry>Right</entry>
	      <entry>Front</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      
      <para>
	You can also select any azimuth-elevation combination from the Command
	Line. For example, at the prompt type
	
	<command>ae 128 17[Enter]</command>
	
	As with many of the Command Line options, this method of selecting views
	provides a finer degree of control/precision when you need it.
      </para>
      
      <para>
	MGED can also display multiple views simultaneously. Go to the Modes menu
	and click on Multipane. Four small panes with different views should
	appear in your Graphics Window, as shown in the following illustration.
      </para>
      
      
      <figure>
	<title>Multipane View of the Radio</title>
	<screenshot>
	  <graphic fileref="multradioviews.png"/>
	</screenshot>
      </figure>
    </sect1>

    <sect1>
      <title>Working with Shift Grips</title>
      
      <para>
	The Shift Grip options of MGED are handy hot-key and mouse button
	combinations that can be used in two different ways. With regard to our
	present discussion on viewing, the Shift Grips can, in effect, "drag" the
	world around in front of the viewer (but without actually changing the
	coordinates of the viewed objects). The same Shift Grips can also be used
	in Edit mode to actually move or alter the geometry of your objects. In
	both cases, the Shift Grips appear to do the same thing, so it is
	important always to know the mode in which you are operating.
      </para>
      
      <para>
	In general, the SHIFT key translates (moves), the CTRL key rotates, and
	the ALT key constrains (or limits) translation or rotation to a particular
	axis (x, y, or z). These axes correspond to the three mouse buttons as
	follows: the left button represents the x axis, the middle button
	represents the y axis, and the right button represents the z axis. In
	addition, the SHIFT and CTRL keys can be used in conjunction with any
	mouse button to scale an object (although the ALT key will not constrain
	this action). The following table lists all of the key bindings and their
	functions.
      </para>
      
      <table frame='all'>
	<title>Shift Grip Keys and Effects</title>
	<tgroup cols='5' align='center' colsep='1' rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	  <colspec colname='c3'/>
	  <colspec colname='c4'/>
	  <thead>
	    <row>
	      <entry>Function</entry>
	      <entry>Key Combination</entry>
	      <entry>Effect in Normal Viewing</entry>
	      <entry>Effect in Edit Mode</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Translate (Move)</entry>
	      <entry>SHIFT + any mouse button + mouse drag</entry>
	      <entry>Moves view in any direction</entry>
	      <entry>Translates object in any direction</entry>
	    </row>
	    <row>
	      <entry>Rotate</entry>
	      <entry>CTRL + any mouse button + mouse drag</entry>
	      <entry>Rotates view in any direction</entry>
	      <entry>Rotates object in any direction</entry>
	    </row>
	    <row>
	      <entry morerows='2' valign='middle'>Constrain Translation</entry>
	      <entry>SHIFT + ALT + left mouse button + mouse drag</entry>
	      <entry>Moves view in the x direction</entry>
	      <entry>Translates object in the x direction</entry>
	    </row>
	    <row>
	      <entry>SHIFT + ALT + middle mouse button + mouse drag</entry>
	      <entry>Moves view in the y direction</entry>
	      <entry>Translates object in the y direction</entry>
	    </row>
	    <row>
	      <entry>SHIFT + ALT + right mouse button + mouse drag</entry>
	      <entry>Moves view in the z direction</entry>
	      <entry>Translates object in the z direction</entry>
	    </row>
	    <row>
	      <entry morerows='2' valign='middle'>Constrain Rotation</entry>
	      <entry>CTRL + ALT + left mouse button + mouse drag</entry>
	      <entry>Rotates view about the x axis</entry>
	      <entry>Rotates object about the x axis</entry>
	    </row>
	    <row>
	      <entry>CTRL + ALT + middle mouse button + mouse drag</entry>
	      <entry>Rotates view about the y axis</entry>
	      <entry>Rotates object only about the y axis</entry>
	    </row>
	    <row>
	      <entry>CTRL + ALT + right mouse button + mouse drag</entry>
	      <entry>Rotates view about the z axis</entry>
	      <entry>Rotates object aboutthe z axis</entry>
	    </row>
	    <row>
	      <entry>Scale</entry>
	      <entry>SHIFT + CTRL + any mouse button + mouse drag</entry>
	      <entry>Scales view larger or smaller</entry>
	      <entry>Scales object larger or smaller</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
      
      <caution>
	<para>
	  Depending on your window manager or desktop environment settings,     
	  some key combinations may already be designated to perform other      
	  tasks (e.g., resizing or moving a window). If so, you may need to     
	  adjust settings to allow the Shift Grip options to function.          
	  Furthermore, left-handed users may have switched the behavior of the  
	  left and right mouse buttons in their system configurations. In such  
	  instances, the terms left mouse button and right mouse button should  
	  be switched throughout this document.                                 
	</para>
      </caution>
      
      <para>
	Probably the easiest way to familiarize yourself with the Shift Grip
	options is to try them out on your radio. Using the preceding table as a
	guide, experiment with translating, rotating, constraining translation and
	rotation to particular axes, and sizing your radio view.
      </para>
      
      <note>
	<para>
	  Remember, although the Shift Grip options may appear to be            
	  manipulating objects, unless you are in Edit mode they are only       
	  manipulating your view of the objects.                                
	</para>
      </note>
    </sect1>
    
    <sect1>
      <title>Review</title>
      
      <para>
	In this lesson, you:
	
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Created a model radio.</para>
	  </listitem>
	  <listitem>
	    <para>Located  viewing information in the Command Window.</para>
	  </listitem>
	  <listitem>
	    <para>Identified elements of the MGED viewing system.</para>
	  </listitem>
	  <listitem>
	    <para>Viewed your radio from different angles.</para>
	  </listitem>
	  <listitem>
	    <para>Worked with Shift Grips.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter>
  
  <chapter id="Lesson-3">
    <title>Using the Insert Command to Size and Place Shapes</title>
    
    <para>
      In this lesson, you will:
      
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Create a sphere and a right circular cylinder using the make command.</para>
	</listitem>
	<listitem>
	  <para>Create the same two shapes using the in (insert) command.</para>
	</listitem>
	<listitem>
	  <para>Combine arguments on the Command Line to streamline the entry of variables.</para>
	</listitem>
	<listitem>
	  <para>Develop a combined-command form to help manage Command Line variables.</para>
	</listitem>
	<listitem>
	  <para>Consider conventions for choosing names for your objects.</para>
	</listitem>
	<listitem>
	  <para>View your shapes from different perspectives using options of the View menu.</para>
	</listitem>
	<listitem>
	  <para>Quit the MGED program.</para>
	</listitem>
      </itemizedlist>  
    </para>
    
    <para>
      This lesson focuses on creating shapes from the Command Window using the
      make and in commands. You will create a sphere (sph) and a right circular
      cylinder (rcc) using both commands so that you can see how each command
      works. Later in the lesson, you will practice viewing your model from
      different angles.
    </para>
    
    <sect1>
      <title>Creating a New Database from the Command Window</title>
      
      <para>
	Create a new database and name it shapes.g. Title your database myShapes.
      </para>
    </sect1>

    <sect1>
      <title>Creating a Sphere Using the Make Command</title>
    
      <para>
	Begin by making the Command Window active (usually by clicking anywhere in
	the window). Then, at the MGED prompt, type in the command:
	
	<command>make sph1.s sph [Enter]</command>
      </para>
      
      <para>
	As noted in Lesson 1, this command tells MGED to:
	
	<informaltable frame="all">
	  <tgroup cols='3'>
	    <tbody>
	      <row><entry>make</entry><entry>sph1.s</entry><entry>sph</entry></row>
	      <row><entry>Create a shape</entry><entry>Name it sph1.s</entry>
                   <entry>Make it a sphere</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
	
	<figure>
	  <title>Wireframe Sphere</title>
	  <screenshot>
	    <graphic fileref="wireframesphere.png"/>
	  </screenshot>
	</figure>
      </para>
      
      <para>
	A sphere shape has now been created, and a wireframe drawing should appear
	in your Graphics Window.
      </para>
      <para>
	To make the rcc from the Command Window prompt, type:
	
	<command>make rcc1.s rcc[Enter]</command>
      </para>
      
      <para>
	Your Graphics Window should now display a large rcc that, from the default
	view of az35, el25, looks as if it intersects the sphere you previously
	created.
	
	<figure>
	  <title>Wireframe Sphere and Right Circular Cylinder</title>
	  <screenshot>
	    <graphic fileref="wireframespherecylinder.png"/>
	  </screenshot>
	</figure>
      </para>
      
      <para>
	Using the make command is a fast and easy way to create a shape; however,
	most models are going to require shapes that have specific parameters,
	such as height and radius. So, a more precise way to create these shapes
	is to use the in (insert) command.
      </para>
    </sect1>
   
    <sect1>
      <title>Using the In Command to Create Shapes</title>
      
      <para>
	Begin by making the Command Window active (usually done by clicking
	anywhere in the window). Then, use the Z (zap) command to clear the
	Graphics Window.  You are now ready to create a sphere using the in
	command. At the MGED prompt type:
	
	<command>in sph2.s sph[Enter]</command>
      </para>

      <para>
	MGED will respond with:
	
	<literal>Enter X, Y, Z of vertex:</literal>
      </para>
      
      <para>
	You must tell MGED where to position the vertex (center) of your sphere in
	space. Type at the MGED prompt:
	
	<command>4 4 4[Enter]</command>
      </para>
      
      <note>
	<para>
	  As you work in MGED, you will often be asked to enter a value for a   
	  vector or a vertex. In MGED, a vector represents the distance and     
	  direction from one point in space to another, and a vertex is one     
	  single point in space. The values entered for a vector are typically  
	  used to create an object with specific dimensions. The values entered 
	  for a vertex place the object in space.
	</para>
      </note>
      
      <para>
	Your sphere will now be placed at (x,y,z)=(4,4,4), as measured in
	millimeters. Notice that the numbers are separated by spaces followed by
	the ENTER key. MGED will now ask you to:
      </para>  
      <literallayout>
      Enter radius:
      
      Type in:
      
      3[Enter]
      </literallayout>
    
      <para>
	The radius of your sphere will be 3 mm. The following is the dialog that
	should appear in your Command Window (including the appropriate
	responses).
	
	<command>mged> in sph2.s sph</command>
	
	<literal>Enter X, Y, Z of vertex: 4 4 4</literal>
	
	<literal>Enter radius: 3</literal>
	
	<literal>51 vectors in 0.000543 sec</literal>
	
	The last line of this dialog is simply a record of the computer's speed in
	drawing the shape. It has no real usefulness to the user at this point.
      </para>
      
      <para>
	A sphere has now been created, and a wireframe drawing similar to the one
	created using the make command should appear in your Graphics Window.
      </para>
      
      <para>
	To make the right circular cylinder, type at the Command Window prompt:
	
	<command>in rcc2.s rcc[Enter]</command>
	
	MGED will ask you to enter values for x, y, and z of the vertex (where you
	want the center of one end of the rcc placed in space). Type:
	
	<command>4 4 0[Enter]</command>
	
	Be sure to leave spaces between each of these numbers.
      </para>
      
      <para>
	MGED will now ask you to enter the x, y, and z values of the height (H)
	vector (i.e., how long you want the rcc to be). Type:
	
	<command>0 0 4[Enter]</command>
	
	The last value you will need to enter is the radius of the rcc. Type:
	
	<command>3[Enter]</command>
	
	The dialog in the Command Window for the creation of the rcc should look
	like this:
      </para>
      
      <literallayout>
      mged> in rcc2.s rcc
      
      Enter X, Y, Z of vertex: 4 4 0
      
      Enter X, Y, Z of height (H) vector: 0 0 4
      
      Enter radius: 3
      
      42 vectors in 0.000214 sec
      </literallayout>
    
      <para>
	You should now have new versions of the sphere and rcc shapes. Notice how
	these two shapes compare in size to the first two you created. The rcc is
	now in proportion to the sphere and is placed in space off to the left in
	your Graphics Window. By specifying the dimensions of the shapes and their
	locations in space, you were able to create the model more precisely.
      </para>
      
      <informaltable>
	<tgroup cols='2'>
	  <tbody>
	    <row>
	      <entry><graphic/></entry>
	      <entry><graphic/></entry>
	    </row>
	    <row>
	      <entry>Shapes Created with Make Command</entry>
	      <entry>Shapes Created with In Command</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

    </sect1>
   
    <sect1>
      <title>Combining Arguments on One Line</title>
      
      <para>
	Another way to use the in command is to combine all of the required
	information on one line. Once you become familiar with using the in
	command, you will probably prefer to use this method as it allows you to
	input all the parameter values more quickly.
      </para>
      
      <para>
	Clear the Graphics Window by using the Z command. Now make another sphere
	by typing after the MGED prompt:
	
	<command>in sph3.s sph 4 4 4 3[Enter]</command>
      </para>
      
      <para>
	The meaning of this longer form of the command is:
      </para>
      
      
      <informaltable>
	<tgroup cols='7'>
	  <tbody>
	    <row>
	      <entry>in</entry>
	      <entry>sph3.s</entry>
	      <entry>sph</entry>
	      <entry>4</entry>
	      <entry>4</entry>
	      <entry>4</entry>
	      <entry>3</entry>
	    </row>
	    <row>
	      <entry>Insert a primitive shape</entry>
	      <entry>Name it sph3.s</entry>
	      <entry>Make the primitive shape a sphere</entry>
	      <entry>Make the x of the vertex a value of 4</entry>
	      <entry>Make the y of the vertex a value of 4</entry>
	      <entry>Make the z of the vertex a value of 4</entry>
	      <entry>Make the radius a value of 3</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      
      <para>
	To make the right circular cylinder using this method, type after the MGED
	prompt:
	
	<command>in rcc3.s rcc 4 4 0 0 0 4 3[Enter]</command>
      </para>
      
      <para>
	The meaning of this command is:
      </para>
      
      <informaltable>
	<tgroup cols='10' align='center' colsep='1' rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	  <colspec colname='c3'/>
	  <colspec colname='c4'/>
	  <colspec colname='c5'/>
	  <colspec colname='c6'/>
	  <colspec colname='c7'/>
	  <colspec colname='c8'/>
	  <colspec colname='c9'/>
	  <colspec colname='c10'/>
	  <tbody>
	    <row>
	      <entry>in</entry>
	      <entry>rcc3.s</entry>
	      <entry>rcc</entry>
	      <entry>4</entry>
	      <entry>4</entry>
	      <entry>0</entry>
	      <entry>0</entry>
	      <entry>0</entry>
	      <entry>4</entry>
	      <entry>3</entry>
	    </row>
	    <row>
	      <entry morerows='1' valign='top'>Insert a primitive shape</entry>
	      <entry morerows='1' valign='top'>Name it rcc3.s</entry>
	      <entry morerows='1' valign='top'>Make the primitive shape a right circular cylinder</entry>
	      <entry morerows='1' valign='top'>Make the x of the vertex a value of 4</entry>
	      <entry morerows='1' valign='top'>Make the y of the vertex a value of 4</entry>
	      <entry morerows='1' valign='top'>Make the z of the vertex a value of 0</entry>
	      <entry>Make the x of the height vector a value of 0</entry>
	      <entry>Make the y of the height vector a value of 0</entry>
	      <entry>Make the z of the height vector a value of 4</entry>
	      <entry morerows='1' valign='top'>Make the radius a value of 3</entry>
	    </row>
	    <row>
	      <entry namest="c7" nameend="c9" align="center">Make the shape four units long, 
	             pointing straight toward positive z</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect1>
    
    <sect1>
      <title>Making a Combined-Command Form for the In Command</title>
      
      <para>
	When you are first starting to use MGED, if you want to use the Command
	Window rather than the GUI, you may want to make yourself some blank,
	combined-command forms for each type of primitive shape you will be
	creating. This can speed up the design process and help remind you of
	which values must be entered for each shape. A form for the sphere might
	be:
      </para>
      
      <informaltable>
	<tgroup cols='10' align='center' colsep='1' rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	  <colspec colname='c3'/>
	  <colspec colname='c4'/>
	  <colspec colname='c5'/>
	  <colspec colname='c6'/>
	  <colspec colname='c7'/>
	  <tbody>
	    <row>
	      <entry>in</entry>
	      <entry>?</entry>
	      <entry>sph</entry>
	      <entry>?</entry>
	      <entry>?</entry>
	      <entry>?</entry>
	      <entry>?</entry>
	    </row>
	    <row>
	      <entry morerows='1' valign='top'>Insert a shape</entry>
	      <entry morerows='1' valign='top'>Name of primitive shape</entry>
	      <entry morerows='1' valign='top'>Type of shape is a sphere</entry>
	      <entry>Value of x</entry>
	      <entry>Value of y</entry>
	      <entry>Value of z</entry>
	      <entry morerows='1' valign='top'>Radius of sph</entry>
	    </row>
	    <row>
	      <entry namest="c4" nameend="c6" align="center">Center</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      
      <para>
	A Combined-Command Form for the rcc might be:
      </para>
      
      <informaltable>
	<tgroup cols='10' align='center' colsep='1' rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	  <colspec colname='c3'/>
	  <colspec colname='c4'/>
	  <colspec colname='c5'/>
	  <colspec colname='c6'/>
	  <colspec colname='c7'/>
	  <colspec colname='c8'/>
	  <colspec colname='c9'/>
	  <colspec colname='c10'/>
	  <tbody>
	    <row>
	      <entry>in</entry>
	      <entry>?</entry>
	      <entry>rcc</entry>
	      <entry namest="c4" nameend="c6" align="center">?</entry>
	      <entry namest="c7" nameend="c9" align="center">?</entry>
	      <entry>?</entry>
	    </row>
	    <row>
	      <entry morerows='1' valign='top'>Insert a primative shape</entry>
	      <entry morerows='1' valign='top'>Name of shape</entry>
	      <entry morerows='1' valign='top'>Type of shape is a right circular cylinder</entry>
	      <entry>Value of x</entry>
	      <entry>Value of y</entry>
	      <entry>Value of z</entry>
	      <entry>Value of x</entry>
	      <entry>Value of y</entry>
	      <entry>Value of z</entry>
	      <entry morerows='1' valign='top'>Radius of rcc</entry>
	    </row>
	    <row>
	      <entry namest="c4" nameend="c6" align="center">Vertex</entry>
	      <entry namest="c7" nameend="c9" align="center">Height vector</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect1>
    
    <sect1>
      <title>Considering MGED Naming Conventions</title>
      
      <para>
	You may have noticed that each time you have created a sphere, or rcc, you
	have given it a different name. MGED doesn't care what name you give a
	shape, but you will find as you develop models that it helps to have some
	formula, or conventions, when naming shapes. Note also that each name must
	be unique in the database, and for BRL-CAD releases prior to 6.0, names
	are limited to 16 characters in length.
      </para>
      
      <para>
	In this lesson, we sometimes assigned names to the shapes based on their
	shape type and the order in which we created them. We did this because the
	shapes had no real function, except to be examples.
      </para>

      <para>
	When you create real-life models, however, you will probably want to
	assign names as we did for the radio component names, which were based on
	their functions (e.g., btn for button, ant for antenna, etc.).
      </para>
      
      <para>
	If you work with more experienced modelers, check with them to see what
	set of conventions they use. If you work alone, develop a set of naming
	conventions that works for you and then use it consistently.
      </para>
    </sect1>
    
    <sect1>
      <title>Viewing the Shapes</title>

      <para>
	Practice viewing your new shapes using the View menu. Manipulate your view
	using the various mouse-key combinations identified in the previous
	lesson.
      </para>
    </sect1>
    
    <sect1>
      <title>Quitting MGED</title>

      <para>
	If you wish to quit MGED, at this point, type either the letter q or the
	word quit after the Command Window prompt and then press ENTER. You may
	also quit the program by selecting Exit from the File menu.
      </para>
    </sect1>
    
    <sect1>
      <title>Review</title>
      
      <para>
	In this lesson, you:
      </para>

      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Created a sphere and a right circular cylinder using the make command.</para>
	</listitem>
	<listitem>
	  <para>Created the same two shapes using the in (insert) command.</para>
	</listitem>
	<listitem>
	  <para>Combined commands to streamline the entry of variables.</para>
	</listitem>
	<listitem>
	  <para>Developed a combined-command form to help manage Command-Line variables.</para>
	</listitem>
	<listitem>
	  <para>Considered MGED naming conventions.</para>
	</listitem>
	<listitem>
	  <para>Viewed your shapes from different perspectives using options of the View menu.</para>
	</listitem>
	<listitem>
	  <para>Quit the MGED program.</para>
	</listitem>
      </itemizedlist>
    </sect1>
  </chapter>

  <chapter id="Lesson-4">
    <title>Assigning Material Properties and Raytracing</title>
    
    <para>
      In this lesson, you will:
      
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Recall primitive shapes made previously.</para>
	</listitem>
	<listitem>
	  <para>Make a region of two primitive shapes.</para>
	</listitem>
	<listitem>
	  <para>Assign material properties to your primitive shapes from the Command Window.</para>
	</listitem>
	<listitem>
	  <para>Clear the Graphics Window and draw the new region.</para>
	</listitem>
	<listitem>
	  <para>Raytrace your design from the GUI.</para>
	</listitem>
	<listitem>
	  <para>Use the GUI to change layers of the Graphics Window.</para>
	</listitem>
	<listitem>
	  <para>Clear the Graphics Window after raytracing a model.</para>
	</listitem>
      </itemizedlist>
    </para>

    <sect1>
      <title>Opening the Database</title>
      
      <para>
	To recall the primitive shapes made in the previous lesson, start MGED and
	go to the File menu and select Open. A control panel will appear with a
	list of folders and files. Select shapes.g and Open. A new box will
	appear, and you should click on OK.
      </para>
      
      <para>
	You should now have two windows prominently displayed on your screen. At
	the MGED prompt in the Command Window, type:
	
	<command>draw sph2.s rcc2.s[Enter]</command>
      </para>
    </sect1>
    
    <sect1>
      <title>Creating a Region</title>
      
      <para>
	Before you can raytrace your design, you have to make a region of the two
	shapes. A region is an object that has uniform material properties. Most
	applications that use BRL-CAD models consider regions as the basic
	components of the model. Regions are constructed using the basic Boolean
	operations of union, intersection, and subtraction, which are discussed in
	the next chapter.
      </para>
      
      <para>
	At the MGED prompt, type:
	
	<command>r shapes2.r u sph2.s u rcc2.s[Enter]</command>
	
      </para>
      
      <note>
	<para>
	  Make sure you key in the information correctly before you press ENTER. 
	  Spaces, or the lack thereof, are important.
	</para>
      </note>
      
      <para>
	This command tells MGED to:
	
	<informaltable>
	  <tgroup cols='6'>
	    <tbody>
	      <row>
		<entry>r</entry>
		<entry>shapes2.r</entry>
		<entry>u</entry>
		<entry>sph2.s</entry>
		<entry>u</entry>
		<entry>rcc2.s</entry>
	      </row>
	      <row>
		<entry>Make a region</entry>
		<entry>Name it shapes2.r</entry>
		<entry>Add the volumeof the shape</entry>
		<entry>sph2.s</entry>
		<entry>Add the volume of the shape</entry>
		<entry>rcc2.s</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
    </sect1>
    
    <sect1>
      <title>Assigning Material Properties to a Region</title>

      <para>
	Now type in:
	
	<command>mater shapes2.r[Enter]</command>
	
	MGED will respond with:
	
      </para>
      <literallayout>
   shader=
   
   Shader? ('del' to delete, CR to skip)
      </literallayout>
      
      <para>
	Type in:
	
	<command>plastic[Enter]</command>
	
	MGED will ask:
	
      </para>
      <literallayout>
   Color = (no color specified)

   Color R G B (0..255)? ('del' to delete, CR to skip)
      </literallayout>

      <para>
	Type in:
     
	<command>0 255 0[Enter]</command>
	
	This will assign a light green color to the region. MGED will now ask:
      </para>

      <literallayout>
   Inherit = 0 lower nodes (towards leaves) override

   Inheritance (0/1)? (CR to skip)
      </literallayout>

      <para>
	Type:
	
	<command>0[Enter]</command>
	
	When you have completed this set of commands, your Command Window should
	look like the following example:
      </para>
      
      <figure>
	<title>The Command Window Screen</title>
	<screenshot>
	  <graphic fileref="commandwindow.png"/>
	</screenshot>
      </figure>
      
      <para>
	The one-line version of this set of commands would be:
	
	<command>mater shapes2.r plastic 0 255 0 0[Enter]</command>
	
	Diagrammed, this command says to:
      </para>
      
      <informaltable>
	<tgroup cols='5'>
	  <tbody>
	    <row>
	      <entry>mater</entry>
	      <entry>shapes2.r</entry>
	      <entry>plastic</entry>
	      <entry>0 255 0</entry>
	      <entry>0</entry>
	    </row>
	    <row>
	      <entry>Assign material properties to:</entry>
	      <entry>the region called shapes2.r</entry>
	      <entry>Make the region of plastic</entry>
	      <entry>Give it a color of light green</entry>
	      <entry>Do not inherit colors or material type</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect1>
    
    <sect1>
      <title>Clearing the Graphics Window and Drawing the New Region</title>

      <para>
	An easy way to clear the Graphics Window of the old design and draw the
	new region is to type at the MGED prompt:
	
	<command>B shapes2.r[Enter]</command>
	
	This command tells MGED to:
      </para>
      
      <informaltable>
	<tgroup cols='2'>
	  <tbody>
	    <row>
	      <entry>B</entry>
	      <entry>shapes2.r</entry>
	    </row>
	    <row>
	      <entry>Blast (clear) the Graphics Window and draw</entry>
	      <entry>The region named shapes2.r</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      
      <para>
	The Blast command is shorthand for the combination of the Z and draw
	commands.
      </para>
    </sect1>
    
    <sect1>
      <title>Raytracing Your Model</title>
      
      <para>
	Now go to the File menu and select Raytrace. A dialog box called the
	Raytrace Control Panel will appear. At the top are menus for Framebuffer
	and Objects. Select Framebuffer. A drop-down menu will appear with six
	choices: Active, All, Rectangle Area, Overlay, Interlay, and Underlay.
	Make sure the Active, All, and Underlay options are activated (as shown by
	the presence of a red indicator to the left of each choice). Select OK.
      </para>
      
      <note>
	<para>
	  Note: When you select Raytrace from this dialog window, you start an  
	  auxiliary program (rt) of the BRL-CAD package. The program only       
	  raytraces objects that have been drawn in the Graphics Window. You    
	  may have many shapes, regions, or combinations in a database, but if  
	  they aren't currently drawn in the Graphics Window, the raytracer     
	  will ignore them.                       
	</para>
      </note>
      
      <para>
	Change the background color produced by the raytracer by selecting
	Background Color  in the Raytrace Control Panel. A drop-down menu will
	appear with some predefined color choices plus a color tool. Select the
	white option. The select button should now appear white, in accordance
	with your selection.
      </para>
      
      <para>
	Next select Raytrace from the four options along the bottom of the box.
	The Graphics Window should start changing, and you will soon see your
	design in shades of green with the wireframe superimposed on the design,
	as shown in the following example:
      </para>
      
      <figure>
	<title>Raytraced Shapes</title>
	<screenshot>
	  <graphic fileref="raytracedshapes.png"/>
	</screenshot>
      </figure>
      
      <para>
	As we have seen, you can specify the background color for the raytraced
	image.
      </para>
      
      <para>
	You can also fill the entire framebuffer with the background color. To do
	this, select the desired color and then click the fbclear (framebuffer
	clear) button at the bottom of the Raytrace Control Panel.
      </para>
    </sect1>

    <sect1>
      <title>Changing Layers of the Graphics Window</title>
      
      <para>
	The Graphics Window of MGED is used to display different types of
	graphical information: 3D wireframes and 2D pixels (or images).
	Conceptually, each type of data occupies a separate layer in the display.
	The 3D wireframes occupy the wireframe layer, while the 2D pixels (images)
	occupy the framebuffer layer. These layers can be thought of as
	transparencies, and the order in which they are stacked and displayed can
	be changed.
      </para>
      
      <para>
	As mentioned previously, there is a Framebuffer menu within the Raytrace
	Control Panel. At the top of this menu is a toggle button labeled Active.
	This turns the display of the framebuffer layer on and off. Near the
	bottom of the same menu are three radio buttons: Overlay, Interlay, and
	Underlay. When the underlay mode is selected, the pixel data are displayed
	under or behind the vector data. Conversely, when the overlay mode is
	selected, the pixel data are in front of the vector data. The interlay
	option is similar to the overlay mode. The subtle difference is an
	advanced topic not covered here.
      </para>
      
      <informaltable frame="none">
	<tgroup cols='2'>
	  <tbody>
	    <row>
	      <entry><graphic/></entry>
	      <entry><graphic/></entry>
	    </row>
	    <row>
	      <entry>Framebuffer in Underlay Mode</entry>
	      <entry>Framebuffer in Overlay Mode</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      
      <para>
	To see how this works, go to the framebuffer menu and select Overlay.
	Notice that the wireframe representation disappears. Where does it go? If
	you answered "behind the framebuffer," you would be correct. To view the
	model's geometry, you would have to make the framebuffer inactive or
	select underlay  mode.
      </para>
      
      <para>
	The wireframe layer has a yellow dot in the center that marks the center
	of the view talked about in Lesson 2. This allows you to determine whether
	the framebuffer is in overlay or underlay mode. If you can see the yellow
	dot, the framebuffer is in underlay mode. If you've told MGED to draw some
	geometry and the Graphics Window seems to remain blank, you are probably
	seeing a blank framebuffer masking the wireframe layer.
      </para>
      
      <para>
	Note that you can change the view in the wireframe, but the view in the
	framebuffer does not automatically update to match. It is not possible to
	directly manipulate the view in the framebuffer. You must raytrace again
	in order to update the framebuffer image.
      </para>
    </sect1>
    
    <sect1>
      <title>Clearing the Graphics Window</title>
      
      <para>
	To completely clear the Graphics Window, you have to handle both the
	wireframe and framebuffer layers. Recall that you can clear the wireframe
	layer with the Z command. For the framebuffer layer, there is the fbclear
	button on the Raytrace Control Panel.
      </para>
      
      <para>
	In some instances, you may prefer to turn off the framebuffer instead of
	clearing it. When the framebuffer is turned off, MGED runs faster because
	it doesn't have to redraw the framebuffer each time it updates the
	display. You can turn the framebuffer on and off by toggling the Active
	item in the Raytrace Control Panel's framebuffer menu.
      </para>
      
      <note>
	<para>
	  Note that in BRL-CAD versions 5.1 and later, turning off the          
	  framebuffer does not destroy the image it contains. Turning it back   
	  on displays the same image. However, in earlier versions of the       
	  package, the contents of the framebuffer are lost when it is turned   
	  off.                          
	</para>
      </note>
    </sect1>
    
    <sect1>
      <title>Review</title>
      
      <para>
	In this lesson you:
	
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Recalled primitive shapes made previously.</para>
	  </listitem>
	  <listitem>
	    <para>Made a region of two primitive shapes.</para>
	  </listitem>
	  <listitem>
	    <para>Assigned material properties to your primitive shapes from the Command Window.</para>
	  </listitem>
	  <listitem>
	    <para>Cleared the Graphics Window and draw the new region.</para>
	  </listitem>
	  <listitem>
	    <para>Raytraced your design from the GUI.</para>
	  </listitem>
	  <listitem>
	    <para>Used the GUI to change layers of the Graphics Window.</para>
	  </listitem>
	  <listitem>
	    <para>Cleared the Graphics Window after raytracing a model.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter>

  <chapter id="Lesson-5">
    <title>Lesson 5: Learning About Boolean Expressions</title>
    
    <para>
      In this lesson, you will:
      
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Learn about combinations and regions.</para>
	</listitem>
	<listitem>
	  <para>Learn about Boolean operations.</para>
	</listitem>
	<listitem>
	  <para>Make regions with Boolean operations.</para>
	</listitem>
      </itemizedlist>
      
      <caution>
	<para>
	  This is an important lesson because Boolean operations are critical   
	  to the modeling process. The order in which shapes are combined and   
	  the operators used to combine the shapes will determine how the MGED  
	  program interprets your model.                                        
	</para>
	
	<para>
	  The correct use of Boolean expressions to modify geometric shapes is  
	  a key skill in constructive solid modeling. It important to review    
	  these concepts as many times as necessary. If it is difficult to      
	  absorb them all now, come back to them later.
	</para>
      </caution>
    </para>
    
    <sect1>
      <title>Combinations and Regions: Boolean Tools</title>
      
      <para>
	There are conceptually two objects in MGED that support Boolean
	operations. One is called a combination, the other is called a region.
      </para>
      
      <para>
	As mentioned earlier, a typical geometric shape in MGED is called a
	primitive. However, single primitives are often insufficient to fully
	describe the complex shape of the object being modeled. So, combining two
	or more primitive shapes into other shapes (called combinations) using
	Boolean operators allows you to artfully imitate the shape and form of
	most complicated objects.
      </para>
      
      <para>
	The previous chapter noted that material properties are associated with
	regions. Like combinations, regions use Boolean operations to create
	complex shapes. The difference is that regions are shapes that have
	material properties. They occupy three-dimensional space, rather than
	simply defining a shape in space.
      </para>
      
      <para>
	You can think of primitives and combinations as a blueprint for an object.
	The actual object is created when a region is made. For example, you might
	make a blueprint of an object such as a coffee mug, but then create that
	mug from different types of material (e.g., ceramic or glass). Regardless
	of the material, the blueprint is the same.
      </para>
      
      <para>
	When Boolean operations are used to build up complex shapes from simpler
	shapes, we can call the result a shape combination. When they are used to
	define other logical or hierarchical structure within the database, the
	result may be referred to as a group or an assembly combination.
      </para>
    </sect1>
    
    <sect1>
      <title>Boolean Operations</title>
      
      <para>
	The three Boolean operators employed by the MGED program are union,
	subtraction, and intersection. You can use Boolean operations to combine
	shapes to produce more complex shapes.
	
	<itemizedlist>
	  <listitem>
	    <para>Union Shapes: Merge two shapes.</para>
	  </listitem> 
	  <listitem>
	    <para>Subtract Shapes: Remove the volume of one shape from another.</para>
	  </listitem> 
	  <listitem>
	    <para>Intersect Shapes: Use only the parts of the two shapes that overlap.</para>
	  </listitem> 
	</itemizedlist>
      </para>
      
      <sect2>
	<title>Union</title>
	<para>
	  The union operator, u, joins shapes so that any point in at least one of
	  them will be part of the result. Union is a powerful and frequently used
	  operator.
	</para>
	
	<figure>
	  <title>The Union of Two Spheres</title>
	  <screenshot>
	    <graphic fileref="unionspheres.png"></graphic>
	  </screenshot>
	</figure>
      </sect2>
      
      <sect2>
	<title>Subtraction</title>
	<para>
	  When a primitive shape has a second, overlapping shape subtracted from it,
	  the result is that the second shape disappears, together with any common
	  volume it had with the first shape. The - (minus sign) operator signifies
	  subtraction or difference. This operation is especially useful in
	  hollowing a body, removing an oddly shaped piece of a primitive shape, or
	  accounting for edge intersections of walls, plates, piping, or other
	  connected shapes.
	</para>
	
	<para>
	  In the following example, a dotted red line indicates that the sphere
	  being subtracted extends inside the sphere on the right. This overlapping
	  portion is partially out of view in the raytraced image.
	</para>
	<figure>
	  <title>Subtraction of One Sphere from Another Sphere</title>
	  <screenshot>
	    <graphic fileref="subtractionspheres.png"></graphic>
	  </screenshot>
	</figure>
      </sect2>

      <sect2>
	<title>Intersection</title>
	
	<para>
	  The Boolean intersection operation, signified by a + (plus sign) operator,
	  combines two primitive shapes that overlap each other, saving only their
	  common volume (the nonoverlapped areas will not be present). An easy way
	  to understand intersections is to think of shapes as roads. The
	  intersection is the place where two roads overlap.
	</para>
	
	<para>
	  Although many people find intersection operations harder to understand
	  than unions and subtractions, unusual/complex shapes can be expressed
	  using the intersection operator. For example, you can model a magnifying
	  lens as the intersection of two spheres.
	</para>
	
	<para>
	  The intersection operation is rarely useful unless, as shown in the
	  following figure, at least two shapes overlap. The intersection of two
	  shapes having no common points (i.e., no overlap) is the null set, so it
	  includes no points of space at all.
	</para>
	
	<figure>
	  <title>Intersection of Two Spheres</title>
	  <screenshot>
	    <graphic fileref="subtractionspheres.png"></graphic>
	  </screenshot>
	</figure>
	
	<para>
	  There is one important restriction when using the Boolean subtraction and
	  intersection operators. There must be a first shape from which a second
	  shape can be subtracted or intersected. If you have only one shape within
	  a region or combination, the operator will be ignored and the union
	  operator will always be used.
	</para>
      </sect2>
    </sect1>
    
    <sect1>
      <title>Making Regions with Boolean Operations</title>
      
      <para>
	Begin by opening the database shapes.g that you created in Lesson 3. At
	the Command Window prompt, type:
	
	<command>draw sph2.s rcc2.s[Enter]</command>
	
	This lets us see the shapes we will be using to create our regions. As
	seen earlier, the two shapes should look something like the following:
      </para>
      
      <figure>
	<title>Two Primitive Shapes</title>
	<screenshot>
	  <graphic fileref="twoprimitivespheres.png"></graphic>
	</screenshot>
      </figure>
      
      <para>
	In this lesson, we will create different shapes to demonstrate the
	function of Boolean operations. In the Command Window, type the following:
	
	<command>r part1.r u rcc2.s - sph2.s[Enter]</command>
	
	This command tells MGED to:
      </para>
      
      <informaltable>
	<tgroup cols='6'>
	  <tbody>
	    <row>
	      <entry>r</entry>
	      <entry>part1.r</entry>
	      <entry>u</entry>
	      <entry>rcc2.s</entry>
	      <entry>-</entry>
	      <entry>sph2.s</entry>
	    </row>
	    <row>
	      <entry>Make a region</entry>
	      <entry>Call it part1.r</entry>
	      <entry>Merge...</entry>
	      <entry>The shape named rcc2.s</entry>
	      <entry>Subtract...</entry>
	      <entry>The shape named sph2.s</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      
      <note>
	<para>
	  Note: The first member always has a lowercase u for an operator. The  
	  second and subsequent members can use -, +, or u as needed. The       
	  process of determining which operators to use, and in what order, is  
	  discussed in a more advanced tutorial.                                
	</para>
      </note>
      
      <para>
	In the previous lesson, we applied material properties to objects from the
	Command Line. Now we are going to use the graphical interface to do the
	same thing. From the Edit menu, choose Combination Editor. This will pop
	up a dialog box. Click the button to the right of the Name entry box and
	then click on Select from All. A drop-down menu will appear with the
	regions you have created. Select part1.r. The result should look like the
	following:
      </para>
      
      <figure>
	<title>Combination Editor</title>
	<screenshot>
	  <graphic fileref="combinationeditor.png"></graphic>
	</screenshot>
      </figure>
      
      <para>
	Click on the button next to Color and select red from the pull-down menu.
      </para>
      
      <para>
	Now click the OK button at the bottom left of the dialog window. This will
	apply your changes and close the panel.
      </para>
      
      <para>
	At the moment, we have only the primitive shapes displayed, not the
	region. Before we can raytrace, we must remove the primitive shapes from
	the display, and draw the region. Otherwise, we will not be able to see
	the region with the color properties we applied. We can do this by typing:
	
	<command>B part1.r</command>
      </para>
      
      <para>
	We are now ready to raytrace this object. From the File menu, bring up the
	Raytrace Control Panel and click the Raytrace button. The image you get
	should look similar to the left-hand image that follows. Note that it may
	take several minutes to raytrace the window, depending on the speed of
	your particular system.
      </para>
      
      <informaltable>
	<tgroup cols='2'>
	  <tbody>
	    <row>
	      <entry><graphic/></entry>
	      <entry><graphic/></entry>
	    </row>
	    <row>
	      <entry>Raytraced part1.r</entry>
	      <entry>Raytraced part2.r</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      
      <para>
	You should see that a spherical "bite" has been taken out of the top of
	the cylinder.
      </para>
      
      <para>
	Next we will make a blue region using the intersection operator instead of
	subtraction. Once again, we start by creating a region:
	
	<command>r part2.r u rcc2.s + sph2.s[Enter]</command>
      </para>
      
      <para>
	For comparison to the GUI approach used to make part1.r, let's use the
	Command Line to assign the color to part2.r:
	
	<command>mater part2.r plastic 0 0 255 0[Enter]</command>
      </para>
      
      <para>
	Finally, Blast this new region onto the display as follows:
	
	<command>B part2.r[Enter]</command>
      </para>
      
      <para>
	Now raytrace the object. It should look similar to the preceding
	right-hand image.
      </para>
      
      <note>
	<para>
	  Note: Remember to clear the Graphics Window and draw your new region  
	  or combination before trying to raytrace the model. The raytracer     
	  ignores a region or combination that is not drawn in the Graphics     
	  Window. The color of the wireframe is your clue. If it doesn't        
	  reflect the colors you've assigned (e.g., everything is drawn in red  
	  even though you've assigned other colors), then you haven't cleared   
	  the screen of the primitive shapes and drawn the new region or        
	  combination since the time you made it.             
	</para>
      </note>
      
      <para>
	When you use the intersection operator, the order in which you specify the
	shapes doesn't matter. We would have gotten the same results if we had
	specified the Boolean operation as
	
	<command>r part2.r u sph2.s + rcc2.s</command>
      </para>
      
      <para>
	However, when using the subtraction operator, the order of the two shapes
	is very important. Let's make a region with the order of the shapes
	reversed from that used for part1.r:
	
	<command>r part3.r u sph2.s - rcc2.s</command>
      </para>
      
      <para>
	This time we won't bother to set a color. (When no color is set for
	objects, the raytracer (rt) will use a color of white. However, these
	objects may appear gray because of the amount of light in the scene.)
	Blast this design to the display and raytrace it:
      </para>
      
      <figure>
	<title>Raytrace part3.r</title>
	<screenshot>
	  <graphic fileref="rtpt3.png"/>
	</screenshot>
      </figure>
      
      <para>
	Now let's raytrace all three objects we have created together. To draw the
	three regions at once, we could type:
	
	<command>B part1.r part2.r part3.r</command>
      </para>
      
      <para>
	Doing this once is no problem. However, if these were three parts that
	made up some complex object, we might like to be able to draw all of them
	more conveniently. To make drawing a collection of objects together
	easier, we create an assembly combination to gather them all together. We
	will create one called dome.c for our three regions. This is accomplished
	by the following command:
	
	<command>comb dome.c u part1.r u part2.r u part3.r</command>
      </para>
      
      <para>
	Notice the similarity between this command and the r command we used to
	create the regions.
      </para>
      
      <para>
	Remember from the discussion at the beginning of this lesson, the
	difference between a region and a combination is that combinations are not
	necessarily composed of only one kind of material. Several objects of
	different materials can make up an assembly combination such as the one we
	have just created.
      </para>
      
      <note>
	<para>
	  Because creating assembly combinations is a very common task, there   
	  is a shortcut command-the g (for group) command-to help make the task 
	  easier. Creating dome.c using this command would look as follows:     
	  
	  <command>g dome.c part1.r part2.r part3.r</command> 
	  
	  Notice that you don't have to type the u Boolean operators. The g     
	  command unions all of its arguments.                                  
	</para>
      </note>
      
      <para>
	All that is necessary to draw all three objects is the much simpler
	command:
	
	<command>B dome.c</command>
      </para>
      <para>
	Now we can raytrace the collected set and get the following image:
      </para>
      
      <figure>
	<title>Raytraced dome.c</title>
	<screenshot>
	  <graphic fileref="rtdome.png"/>
	</screenshot>
      </figure>
    </sect1>
    
    <sect1>
      <title>Operator Precedence</title>
      
      <para>
	The shapes we have created here are fairly simple. In each case, a single
	primitive shape is unioned, and subtraction or intersection operations are
	performed on that single primitive shape. You should know that it is
	possible to use much more complex Boolean equations to create the shape of
	objects. When you want to make such objects, keep in mind the precedence
	of the Boolean operations. In the Boolean notation we are using, the
	subtraction and intersection operators both have higher precedence than
	the union operator has. So, for example:
	
	<command>comb demo.c u shape1 - shape2 u shape3 - shape4 + shape5</command>
      </para>
      
      <para>
	This would result in the following Boolean expression:
	
	<literal>(shape1 - shape2) u ( (shape3 - shape4) + shape5)</literal>
      </para>
    </sect1>
    
    <sect1>
      <title>Review</title>
      
      <para>
	In this lesson, you:
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Learned about combinations and regions.</para>
	  </listitem>
	  <listitem>
	    <para>Learned about Boolean operations.</para>
	  </listitem>
	  <listitem>
	    <para>Made regions with Boolean operations.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter>

  <chapter id="Lesson-6">
    <title>Creating a Goblet</title>
    
    <para>
      In this lesson, you will:
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Create a new database.</para>
	</listitem>
	<listitem>
	  <para>Create, edit, and copy primitive shapes to make the parts of the goblet.</para>
	</listitem>
	<listitem>
	  <para>Make regions of the parts.</para>
	</listitem>
	<listitem>
	  <para>Make a combination of the regions.</para>
	</listitem>
	<listitem>
	  <para>View a data tree. </para>
	</listitem>
	<listitem>
	  <para>Raytrace your completed goblet.</para>
	</listitem>
      </itemizedlist>
    </para>
    
    <para>
      In this lesson, you will create a goblet similar to the one in the
      following example.
      
      <figure>
	<title>Raytraced Goblet</title>
	<screenshot>
	  <graphic fileref="rtgoblet.png"/>
	</screenshot>
      </figure>
    </para>
    
    <sect1>
      <title>Creating a New Database</title>
      <para>
	First, start MGED from the shell prompt. Select File from the menu bar and
	then New. A dialog box will appear, and it will ask you for a new database
	name. Type in goblet.g at the end of the path name and click on OK to
	create the new database. The program should tell you that the database was
	successfully created and it is using millimeters for its unit of measure.
      </para>
    </sect1>
    
    <sect1>
      <title>Creating, Editing, and Copying the Parts of the Goblet</title>
      
      <sect2>
	<title>Creating the Goblet Base</title>
	
	<para>
	  Go to the menu bar, select the Cones and Cylinders category, and then select
	  rcc for right circular cylinder. A dialog box will appear asking you to
	  name the rcc. Type in base1.s and then click on Apply (or press ENTER). A
	  tall cylinder will appear in the Graphics Window that is ready for you to
	  edit.
	</para>
      </sect2>
      
      <sect2>
	<title>Editing the Base</title>
	
	<para>
	  Go to the menu bar and select Edit and then Set H. Place the mouse pointer
	  in the lower half of the Graphics Window and click on the middle mouse
	  button several times. The cylinder will become shorter as you click. (Note
	  that the closer your pointer is to the midpoint of the Graphics Window,
	  the smaller the change will be. As you click farther away from the middle,
	  the changes will be greater.) Continue clicking until the cylinder looks
	  like a flat disk, as shown in the following figure. Click on Accept when
	  done.
	  
	  <figure>
	    <title>The rcc Goblet Base</title>
	    <screenshot>
	      <graphic fileref="gobletbase.png"/>
	    </screenshot>
	  </figure>
	</para>
      </sect2>
      
      <sect2>
	<title>Creating the Goblet Stem</title>
   
	<para>
	  Go to the menu bar, select Create, select Ellipsoids, and then click on
	  sph to select a sphere. You will be asked to provide a name for the
	  sphere. Type ball1.s in the name box and then click on Apply. A large
	  sphere will appear in your Graphics Window.
	</para>

	<para>
	  Go to the Edit menu and click on Scale. Place the mouse cursor/pointer in
	  the lower half of the Graphics Window and click the middle mouse button
	  until your sphere is about one-quarter the diameter of the base, as shown
	  in the illustration that follows.

	  <figure>
	    <title>First Sphere on Goblet Stem</title>
	    <screenshot>
	      <graphic fileref="goblet1stsphere.png"/>
	    </screenshot>
	  </figure>
	</para>

	<para>
	  To move the ball on top of the goblet base, press the SHIFT key and left
	  mouse button to drag the sphere into place. You can check your placement
	  by going to the View option of the menu bar and selecting a Front view. In
	  this view, you can align the center line of the sphere with the center
	  line of the rcc. Repeat this process from a Left view. When you believe
	  the sphere is correctly aligned with the rcc, go back to the Edit option
	  and click on Accept.
	</para>
      </sect2>
      
      <sect2>
	<title>Adding Additional Balls to the Goblet Stem</title>
	
	<para>
	  The next step is to add more spheres to your goblet stem. An easy way to
	  do this is to go to the Edit menu and select Primitive Editor. A dialog
	  box will appear. Enter the name for the first sphere you created, ball1.s.
	  Next, click on Reset (to reset the values of the dialog box to those of
	  ball1.s) or hit return in the Name box. Again in the Name box, change
	  ball1.s to ball2.s by using the BACKSPACE key to erase the 1. Type in a 2
	  and then click on Apply.
	</para>
	
	<para>
	  Repeat this process with an sph named ball3.s. When you are done, click on
	  OK to close the Primitive Editor box. You now have three balls for your
	  stem, but you won't be able to see them until you edit them because they
	  are in the same place.
	</para>
	
	<para>
	  An even easier way to make the copies is to use the cp (copy) command as
	  follows:
	  
	  <command>cp ball1.s ball2.s[Enter]</command>
	  
	  <command>cp ball1.s ball3.s[Enter]</command>
	</para>
      </sect2>
     
      <sect2>
	<title>Editing the Balls of the Goblet Stem</title>
	
	<para>
	  To edit the new balls you have created, go to the Edit menu and click on
	  Primitive Selection. A box will appear with the names of your base and
	  balls. Double click on ball2.s to select it. You will see the first ball
	  change color to white. Use the SHIFT key and any mouse button to drag this
	  ball (which is really ball2.s) so that it rests on top of (and slightly
	  overlaps) ball1.s . Check your views to align the ball as you did with the
	  first ball. (Note that this alignment is even easier if you drag using the
	  SHIFT and ALT keys and the right mouse button, which will constrain the
	  movement of the ball to the Z direction.) Click on Accept under the Edit
	  option when finished.
	</para>
	
	<para>
	  If you were modeling a real goblet, you would want the balls of the stem
	  to overlap slightly. If they barely touch, the stem would be very weak. If
	  they do not touch, then the stem would be made of separate pieces of
	  material suspended in space.
	</para>
	
	<para>
	  Repeat these steps to move ball3.s into position. When you are finished,
	  your goblet should look as follows from a front view:
	  
	  <figure>
	    <title>Goblet with Ball Stem</title>
	    <screenshot>
	      <graphic fileref="gobballstem.png"/>
	    </screenshot>
	  </figure>
	</para>
      </sect2>
      
      <sect2>
	<title>Making the Goblet Basin</title>
	<para>
	  The next step is to make the goblet's basin. Go to the Create menu and
	  click on eto to select an elliptical torus. Name the torus basin1.s. Click
	  on Apply. A large eto will appear in your Graphics Window.
	</para>
	
	<para>
	  Go to the Edit menu and select Set C. Place the mouse arrow in the upper
	  half of the Graphics Window and click on the middle mouse button until
	  your eto is approximately the size of the one in the following figure. If
	  you need to, use Scale to make the basin more proportional to the rest
	  object and use the Shift Grips and multiple views to position the basin.
	  
	  <figure>
	    <title>Goblet Base, Stem, and Basin - Front View</title>
	    <screenshot>
	      <graphic fileref="gobbasestembasinfv.png"/>
	    </screenshot>
	  </figure>
	</para>
      </sect2>
    </sect1>
    
    <sect1>
      <title>Making Regions of the Goblet's Base, Stem, and Basin</title>
      
      <para>
	In order for MGED to know what primitives to raytrace, you must first
	designate these areas through Boolean operations. In this example, the two
	Boolean operations used will be the union (u) and the subtraction (-).
      </para>
      
      <para>
	To make the stem a region, type at the Command Window prompt:
	
	<command>r stem1.r u ball1.s u ball2.s u ball3.s[Enter]</command>
      </para>

      <para>
	To make the base a region, type at the prompt:
	
	<command>r base1.r u base1.s - ball1.s[Enter]</command>
      </para>
      
      <para>
	To make the basin a region, type at the prompt:
	
	<command>r basin1.r u basin1.s - stem1.r[Enter]</command>
      </para>
      
      <para>
	Note that when creating base1.r, we subtracted a primitive shape from
	another primitive shape. When creating basin1.r, we subtracted an entire
	region from a primitive shape.
      </para>
    </sect1>
    
    <sect1>
      <title>Making a Combination of the Regions</title>
      <para>
	To combine all the regions into one object, you will need to perform one
	last Boolean operation. At the prompt in the Command Window, type:
	
	<command>comb goblet1.c u basin1.r u stem1.r u base1.r[Enter]</command>
      </para>
      
      <para>
	This operation tells the MGED program to:
      </para>
      <informaltable>
	<tgroup cols='8'>
	  <tbody>
	    <row>
	      <entry>comb</entry>
	      <entry>goblet1.c</entry>
	      <entry>u</entry>
	      <entry>basin1.r</entry>
	      <entry>u</entry>
	      <entry>stem1.r</entry>
	      <entry>u</entry>
	      <entry>base1.r</entry>
	    </row>
	    <row>
	      <entry>Make a combination</entry>
	      <entry>Name it goblet1.c</entry>
	      <entry>The combination will be made of a union of</entry>
	      <entry>the region basin1.r</entry>
	      <entry>and</entry>
	      <entry>the region stem1.r</entry>
	      <entry>and</entry>
	      <entry>the region base1.r</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect1>
    
    <sect1>
      <title>Viewing a Data Tree</title>
      <para>
	MGED requires a certain logical order to the model data tree so it knows
	how to raytrace the various elements. In the goblet, the base and basin
	consist of regions composed of only one primitive shape each. The stem, in
	contrast, consists of a region composed of the union of three spheres. The
	three regions were combined to form a complex object.
      </para>
      
      <para>
	To view the data tree for this combination, type at the Command Window
	prompt:
	
	<command>tree goblet1.c[Enter]</command>
      </para>
      
      <para>
	MGED will respond with:
	<literallayout>
   goblet1.c/

   u basin1.r/R

   u basin1.s

   - stem1.r/R

   u ball1.s

   u ball2.s

   u ball3.s

   u stem1.r/R

   u ball1.s

   u ball2.s

   u ball3.s

   u base1.r/R

   u base1.s

   - ball1.s
	</literallayout>
      </para>
      
      <para>
	The name of the overall combination of this design is goblet1.c. It is
	composed of the three regions: base1.r, stem1.r, and basin1.r. The region
	base1.r is composed of the primitive shape named base1.s minus ball1.s.
	The region stem1.r is composed of three primitive shapes named ball1.s,
	ball2.s, and ball3.s. The region basin1.r is composed of the primitive
	shape named basin1.s minus the region  stem1.r.
      </para>
      
      <para>
	Remember that regions define volumes of uniform material. In the real
	world (and in BRL-CAD), no two objects can occupy the same space. If two
	regions occupy the same space, they are said to overlap. To avoid having
	the base and stem overlap, we subtract ball1.s from base1.s  when we
	create base1.r. We also subtract the stem1.r from basin1.s when we create
	basin1.r. This removes material from one region that would otherwise
	create an overlap with another. The following figure shows the overlap
	between ball1.s and base1.s in blue. This is the volume that is removed
	from base1.r.
      </para>
    </sect1>
    
    <sect1>
      <title>Raytracing the Goblet</title>
      <para>
	To raytrace the goblet using the default material properties of gray
	plastic, go to the File menu and click on Raytrace. When the Raytrace
	Control Panel appears, change the color of the background  by clicking on
	the button to the right of the Background Color box and then clicking on
	the white option  in the drop-down menu. Next, click on Raytrace.
      </para>
 
      <para>
	When you have finished viewing the goblet from the front view, go to the
	View option of the menu bar and select az35, el25 and then raytrace. If
	you want to view the goblet without the wireframe, go to the Framebuffer
	option of the Raytrace Control Panel and click on Overlay. The goblet
	should look similar to the following illustration:
	
	<figure>
	  <title>The Raytraced Goblet from an az35, el25 View</title>
	  <screenshot>
	    <graphic fileref="rtgaz35e125.png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    
    <sect1>
      <title>Review</title>
      <para>
	In this lesson, you:
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Created a new database.</para>
	  </listitem>
	  <listitem>
	    <para>Created, edited, and copied primitive shapes to make the parts of the goblet.</para>
	  </listitem>
	  <listitem>
	    <para>Made regions of the parts.</para>
	  </listitem>
	  <listitem>
	    <para>Made a combination of the regions.</para>
	  </listitem>
	  <listitem>
	    <para>Viewed a data tree.</para>
	  </listitem>
	  <listitem>
	    <para>Raytraced your completed goblet.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter>
  
  <chapter id="Lesson-7">
    <title>Assigning Material Properties to Your Goblet</title>
    <para>
      In this lesson, you will:
      
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Review how to open an existing database.</para>
	</listitem>
	<listitem>
	  <para>Assign colors and the plastic shader to regions of the goblet.</para>
	</listitem>
	<listitem>
	  <para>Use the transparency and mirror reflectance options of the shader.</para>
	</listitem>
	<listitem>
	  <para>Raytrace various forms of your goblet.</para>
	</listitem>
      </itemizedlist>
    </para>
    
    <para>
      In this lesson, you will add material properties to the goblet you created
      in the previous lesson. The finished goblet should appear similar to the
      one in the following example.
      
      <figure>
	<title>The Completed Goblet with Material Properties Assigned</title>
	<screenshot>
	  <graphic fileref="completematgob.png"/>
	</screenshot>
      </figure>
    </para>

    <sect1>
      <title>Review of Opening an Existing Database</title>
      
      <para>
	If you exited after the last lesson, open your goblet database (goblet.g)
	again. The easiest way to do this is to open the database from the
	Terminal Window when first starting MGED. To do this, type at the prompt:
	
	<command>mged goblet.g[Enter]</command>
      </para>
      
      <para>
	Alternatively, you could start the MGED program, and select File from the
	menu bar and then Open. A dialog box will appear and ask you to enter an
	existing database name. Type in goblet.g (or click on it in the directory
	listing) and then click on Open. The program should tell you that the
	database was successfully opened and it is using millimeters for its unit
	of measure. Click on OK.
      </para>
      
      <sect2>
	<title>Drawing the Goblet in the Graphics Window</title>
	
	<para>
	  To draw the goblet you made in the previous lesson, move the mouse pointer
	  to the Command Window and type at the prompt:
	  
	  <command>draw goblet1.c[Enter]</command>
	</para>
	
	<para>
	  A wireframe representation of the goblet should appear in the Graphics
	  Window.
	</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Assigning Colors and the Plastic Shader to Regions of the Goblet</title>
      <para>
	Go to the Edit menu and click on Combination Editor. To select the various
	regions of the goblet you made in the last lesson, go back to the Name box
	and click on the button  to the right of the entry box. A submenu will
	appear. Double click on Select From All Regions. A list of regions created
	for this database will appear, including base1.r, basin1.r, and stem1.r.
	Double click on base1.r to select that region.
      </para>
      
      <para>
	Click on the button to the right of Color  in the Combination Editor, and
	a drop-down menu will appear with a list of available colors along with a
	color tool that will let you create more colors. Click on blue. Next,
	click on the button to the right of the shader box. A list of available
	shaders will appear. Click on plastic. A new set of options will appear.
	You will use two of these options in this lesson. Click on Apply to assign
	the color blue and the plastic shader to the goblet base.
      </para>
      
      <para>
	Repeat this process to assign the color green and plastic shader to the
	stem1.r region and the color yellow and plastic shader to the basin1.r
	region. When you are finished, click on OK to dismiss the Combination
	Editor box.
      </para>
      
      <para>
	Although the changes have been made to the database, the display in the
	Graphics Window doesn't reflect them yet. So, return the mouse pointer to
	the Command Window and type at the prompt:
	
	<command>B goblet1.c[Enter]</command>
      </para>
      
      <para>
	This command clears the screen and redraws the goblet with the color
	selections applied.
      </para>
      
      <sect2>
	<title>Raytracing the Goblet</title>
	<para>
	  To raytrace the goblet, go to the File menu and click on Raytrace. The
	  Raytrace Control Panel will appear. Move your mouse pointer to the button
	  to the right of Background Color and click on the white option. To make
	  the raytracing go faster, you can resize the Graphics Window to make it
	  smaller before you open the raytrace panel. When the window is resized,
	  click on Raytrace to start the raytrace process.
	</para>
	
	<note>
	  <para>
	    Note: As mentioned previously, it is undesirable to have regions that 
	    overlap. Although having overlaps may not always affect the           
	    raytracing process, if the model were going to be statistically       
	    analyzed, overlaps would create problems.
	  </para>
	</note>
	
	<para>
	  While the goblet is raytracing, move your mouse cursor to the Framebuffer
	  option of the Raytrace Control Panel menu bar and click on Overlay. When
	  the raytrace process is finished, you should have a goblet similar to the
	  following example:
	
	  <figure>
	    <title>The Raytraced Goblet</title>
	    <screenshot>
	      <graphic fileref="rtg.png"/>
	    </screenshot>
	  </figure>
	</para>
      </sect2>
    </sect1>
    
    <sect1>
      <title>Using the Transparency and Mirror Reflectance Shader Options</title>
      <para>
	The raytraced goblet looks fairly realistic, but it could be enhanced by
	using other options of the Combination Editor. When you selected the
	plastic shader, a new set of options appeared, allowing you to choose
	various properties or attributes of the shader. Among the options was
	Transparency. You can adjust this property on individual regions by
	entering any value between 0.0  (opaque) and 1.0 (transparent).
      </para>
      
      <para>
	Just as you applied color and a shader to each of the goblet's three
	regions, you can adjust the transparency of each region by (1) selecting
	the region in the Combination Editor, (2) left clicking on the box next to
	Transparency, and (3) entering any value between 0.0 and 1.0.
      </para>
      
      <para>
	For this lesson, open the Combination Editor, click on the button to the
	right of the Name box, choose Select From All Regions in the drop-down
	menu, and then choose the base1.r region. Make sure plastic is the shader
	selected and type in .5 to make your region semi-transparent. Click on
	Apply and repeat this process for each of the other two regions. Then
	Raytrace the goblet, which should look similar to the following:
	
	<figure>
	  <title>The Semi-Transparent Raytraced Goblet</title>
	  <screenshot>
	    <graphic fileref="strtg.png"/>
	  </screenshot>
	</figure>
      </para>
      
      <para>
	The colors of the semi-transparent goblet are brighter than those of the
	opaque goblet because more light is allowed to penetrate the plastic
	material. You could make the goblet more realistic in appearance by
	returning to the Combination Editor and adding a Mirror Reflectance. For
	each region, place your mouse cursor in the box next to this option, click
	the left mouse button, and type in .45. This will cause about half of the
	available light to be reflected off the surface of the goblet.
      </para>
    </sect1>
    
    <sect1>
      <title>Raytracing the New Forms of the Goblet</title>
      
      <para>
	Click on Apply and Raytrace the design. The new image should appear
	similar to the following example:
	
	<figure>
	  <title>The Raytraced Goblet with Mirror Reflectance Added</title>
	  <screenshot>
	    <graphic fileref="rtgmirrorref.png"/>
	  </screenshot>
	</figure>
      </para>
      
      <para>
	The new image is substantially different in appearance from the original
	image. Continue changing the values of transparency and mirror reflectance
	to see how they impact the resulting image.
      </para>
      
      <para>
	Remember that when using these options, the combined value of both options
	should be less than 1.0. The following table shows you just some of the
	many possible combinations you could use:
      </para>
      
      <informaltable frame="all">
	<tgroup cols='2'>
	  <thead>
	    <row>
	      <entry>Transparency Value</entry>
	      <entry>Mirror Reflectance Value</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>.50</entry>
	      <entry>.49</entry>
	    </row>
	    <row>
	      <entry>.35</entry>
	      <entry>.64</entry>
	    </row>
	    <row>
	      <entry>.20</entry>
	      <entry>.57</entry>
	    </row>
	    <row>
	      <entry>.10</entry>
	      <entry>.89</entry>
	    </row>
	    <row>
	      <entry>.89</entry>
	      <entry>.10</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect1>
    
    <sect1>
      <title>Review</title>
      
      <para>
	In this lesson, you:
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Reviewed how to open an existing database.</para>
	  </listitem>
	  <listitem>
	    <para>Assigned colors and the plastic shader to regions of the goblet.</para>
	  </listitem>
	  <listitem>
	    <para>Used the transparency and mirror reflectance options of the shader.</para>
	  </listitem>
	  <listitem>
	    <para>Raytraced various forms of your goblet.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter>

  <chapter id="Lesson-8">
    <title>Assigning More Material Properties to Your Goblet</title>
    <para>
      In this lesson, you will:
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Use the specular and diffuse reflectivity options of the plastic shader.</para>
	</listitem>
	<listitem>
	  <para>Assign values to the refractive index of the plastic shader.</para>
	</listitem>
	<listitem>
	  <para>Assign values to the shininess option of the plastic shader.</para>
	</listitem>
	<listitem>
	  <para>Assign values to the extinction option of the plastic shader.</para>
	</listitem>
	<listitem>
	  <para>Experiment with various combinations of plastic shader options.</para>
	</listitem>
      </itemizedlist>
    </para>
    
    <para>
      Open the goblet.g database using whichever method you prefer. Go to the
      Edit menu and click on Combination Editor. Select basin1.r.
    </para>
    
    <para>
      In the last lesson, we assigned values for two shader
      attributes-transparency and mirror reflectance. In this lesson, we will
      assign values for still other shader properties. When the plastic shader
      is selected for region basin1.r, eight attribute entry boxes currently
      appear in the Combination Editor. These boxes contain either the values
      that the user has previously set (e.g., those we previously set for
      transparency and mirror reflectance) or the default values that the
      raytracer will use if no others are specified. When any of these values is
      modified, the change can be seen in braces in the shader string box and in
      the appropriate attribute entry boxes, as indicated by the arrows in the
      following example:
      
      <figure>
	<title>The Combination Editor</title>
	<screenshot>
	  <graphic fileref="combeditor.png"/>
	</screenshot>
      </figure>
    </para>
    <note>
      <para>
	Note that in BRL-CAD versions prior to 5.2, the default values are    
	used, but they are not displayed in the shader attribute boxes.       
      </para>
    </note>
   
    <para>
      In this example, the shader entry box indicates that the transparency (tr)
      is set at .5 and the mirror reflectance (re) is set at .45. The eight
      abbreviations currently used in the shader entry box are as follows:
    </para>

    <informaltable>
      <tgroup cols='4'>
	<tbody>
	  <row>
	    <entry>tr - transparency</entry>
	    <entry>sp - specular reflectivity</entry>
	    <entry>ri - refractive index</entry>
	    <entry>ex - extinction</entry>
	  </row>
	  <row>
	    <entry>re - mirror reflectance</entry>
	    <entry>di - diffuse reflectivity</entry>
	    <entry>sh - shininess</entry>
	    <entry>em - emission</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    
    <sect1>
      <title>Specular and Diffuse Reflectivity</title>
      <para>
	When light reflects off of a shiny surface, it produces two types of
	reflections. The most noticeable highlights are caused by specular
	reflectivity. The rest of the surface produces diffuse reflectivity. The
	shinier (or glossier) the surface is, such as on a crystal vase, the more
	specular reflectivity that is produced. The duller the surface is, such as
	with a wall painted with flat paint, the more diffuse reflectivity that is
	produced. A model of the relationship between these reflectivities is
	shown in the following illustration:
      
	<figure>
	  <title>Specular vs. Diffuse Reflectivity Model</title>
	  <screenshot>
	    <graphic fileref="specvsdiffmodel.png"/>
	  </screenshot>
	</figure>
      </para>

      <para>
	As seen in the illustration, diffuse reflectivity shows an object's color
	by reflecting ambient light off the object. The upper left ball exhibits
	the maximum value for diffuse reflectivity (1.0), and as a result, its
	surface color is uniform.
      </para>
      
      <para>
	Specular reflectivity, on the other hand, reflects the color of a light
	source. The lowest right ball, with the maximum value for specular
	reflectivity (1.0), shows a white light source being reflected off the
	surface of the ball.
      </para>
      
      <para>
	The range for both specular and diffuse reflectivity is 0.0 through 1.0.
	However, combined values for these are typically equal to 1.0. Remember,
	if you are going to set values for one of these attributes, you need to
	assign a corresponding value to the complementary attribute so that the
	combination of the values equals 1.0.
      </para>
    </sect1>
    
    <sect1>
      <title>Refractive Index</title>
      
      <para>
	When light passes through one medium (e.g., air) into another medium
	(e.g., water), it bends from its original path. The degree to which the
	light bends is called the refractive index. The more dissimilar the media
	are, the greater the degree of refraction that will occur. For example,
	sunlight passing through a diamond will bend more than the same sunlight
	through optical glass. The diamond would have a higher refractive index
	(approximately 2.42) whereas optical glass would have a lower refractive
	index (approximately 1.71).
      </para>
      
      <para>
	The range of index of refraction for MGED is 1.0 (the index for air) or
	greater. This parameter is only useful for materials that have a
	transparency greater than 0. The following drawing of sunlight passing
	through water shows how refraction works.
            
	<figure>
	  <title>A Ray of Sunlight Passing Through a Body of Water</title>
	  <screenshot>
	    <graphic fileref="raythroughwater.png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    
    <sect1>
      <title>Shininess</title>
      <para>
	The shininess of an object affects the size of the specular component of
	the plastic shader. The shinier an object's surface is, the smaller the
	reflection of the light source on the object's surface will be. The range
	for shininess is typically an integer value from 1 to 10.
      </para>
    </sect1>
    
    <sect1>
      <title>Extinction</title>
      <para>
	The term extinction applies to the transmissive component of the plastic
	shader, and it indicates the amount of light absorbed by the object's
	material. The default value is 0.0, and the range can be any nonnegative
	number. Using this attribute can dramatically impact other attributes of
	the shader, especially the refractive index.
      </para>
    </sect1>
    
    <sect1>
      <title>Emission</title>
      <para>
	Emission is a relatively new feature that has been added to the BRL-CAD
	package. It concerns the amount of artificial brightness of the object.
      </para>
    </sect1>
    
    <sect1>
      <title> Applying Attributes of the Plastic Shader to the Goblet</title>
      <para>
	Now that you understand the various attributes of the plastic shader, it
	is time to experiment with how they affect the final product-the goblet
	you created in the previous two lessons. You have already assigned values
	for transparency and mirror reflectance. Now add the attributes of
	specular reflectivity and diffuse reflectivity to basin1.r. Once you see
	how these two attributes affect your design, add the refractive index,
	then shininess and extinction. You might want to capture some of these
	changes so that you can refer to them later, when you are creating other
	models using the plastic shader. Remember to click Apply in the
	Combination Editor to actually incorporate the changes.
      </para>
      
      <para>
	As you change the values for the attributes of the plastic shader, you
	will notice that some changes do not significantly alter the design. This
	is because there are a variety of ways to produce a particular look on an
	object. The following are two examples of the goblet with various values
	of the plastic attributes (which do create a noticeable difference)
	applied to basin1.r.
      
	<figure>
	  <title>Goblet Assigned .9 for Specular Reflectivity and .1 for Diffuse Reflectivity</title>
	  <screenshot>
	    <graphic fileref="gob9spec1diff.png"/>
	  </screenshot>
	</figure>
	
	<figure>
	  <title>Same Goblet Also Assigned a Value of .5 for Extinction</title>
	  <screenshot>
	    <graphic fileref="gob9spec1diff5extin.png"/>
	  </screenshot>
	</figure>
      </para>
      
      <para>
	By the time you have finished experimenting with changing attributes of
	the plastic shader, your Combination Editor window might look something
	like this:
	
	<figure>
	  <title>The Combination Editor Window</title>
	  <screenshot>
	    <graphic fileref="combedwindow.png"/>
	  </screenshot>
	</figure>
      </para>
      
      <para>
	Notice that while the shader string entry box reflects the values set by
	the user in the attribute entry boxes (e.g., the Transparency of .5), it
	does not reflect the default values (e.g., the Shininess of 10).
      </para>
    </sect1>
    
    <sect1>
      <title>Review</title>
      <para>
	In this lesson, you:
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Used the specular reflectivity and diffuse reflectivity options of the plastic shader.</para>
	  </listitem>
	  <listitem>
	    <para>Assigned values to the refractive index of the plastic shader.</para>
	  </listitem>
	  <listitem>
	    <para>Assigned values to the shininess option of the plastic shader.</para>
	  </listitem>
	  <listitem>
	    <para>Assigned values to the extinction option of the plastic shader.</para>
	  </listitem>
	  <listitem>
	    <para>Experimented with various combinations of plastic shader options.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter>

  <chapter id="Lesson-9">
    <title>Creating a Globe in a Display Box</title>
    <para>
      In previous lessons, you combined various shapes into new objects. These
      new objects have been created using solid building blocks, much like those
      used in a wooden toy truck. However, in real life, most of the objects
      that you will design will consist of an outside shell and various inside
      parts. Therefore, in this lesson you will:
    </para>
    
    <itemizedlist mark='bullet'>
      <listitem>
	<para>Use the GUI to create a display box using arb8 shapes.</para>
      </listitem>
      <listitem>
	<para>Create a globe inside the display box.</para>
      </listitem>
      <listitem>
	<para>Assign material properties to make the objects appear more realistic.</para>
      </listitem>
      <listitem>
	<para>Rotate an object 180'0 using the rotate option of the Edit menu</para>
      </listitem>
      <listitem>
	<para>Use the color option of the Combination Editor to produce customized colors.</para>
      </listitem>
    </itemizedlist>
    
    
    <sect1>
      <title>Create a New Database</title>
      <para>
	Begin by creating a new database. Name your new file cube.g.
      </para>
    </sect1>
    
    <sect1>
      <title>Creating the Display Box</title>
      <para>
	Go to the Create menu, select the Arbs category, and then select an arb8
	(arbitrary convex polyhedron with eight vertices). When asked to provide a
	name for the arb8, name it cube1.s. Click on Apply. Go to the Edit menu
	and click on Accept. You now have a cube for the outside of the display
	box, as in the following:
      
	<figure>
	  <title>The Outside of the Display Box</title>
	  <screenshot>
	    <graphic fileref="outdisbox.png"/>
	  </screenshot>
	</figure>
      </para>
      
      <para>
	Repeat the first part of this process to produce another arb8, this time
	calling this shape cube2.s. Go to the Edit menu and click on Scale. Place
	the mouse pointer in the lower half of the Graphics Window screen and
	click the middle mouse button until the second cube is slightly smaller
	than the first cube, as follows:
      
	<figure>
	  <title>The Inside and Outside of the Display Box</title>
	  <screenshot>
	    <graphic fileref="inoutdispbox.png"/>
	  </screenshot>
	</figure>
      </para>
      
      <para>
	Go to the View menu and change view to Front. Go to the Edit menu and
	click on Translate (move). Hold down the SHIFT key and drag the inside
	cube into position in the center of the outside cube. Repeat this process
	from the Top view and Left view until the smaller cube is placed in the
	center of the outside cube when viewed from all perspectives. When you are
	finished, go back to Edit and click on Accept.
      </para>
    </sect1>

    <sect1>
      <title>Create a Globe Inside the Display Box</title>
      <para>
	Go to the Create menu and select sph from the list of Ellipsoids. Name the
	shape globe1.s and click on Apply.
      </para>
      
      <para>
	A sphere should appear inside the cube in the Graphics Window. Change View
	to Front.
      </para>
      
      <para>
	Go to the Edit menu and select Scale. Reduce the size of the sphere until
	it will fit inside of the cube and then drag it into the center of the
	cube. Go to Edit and Accept your changes. Your globe and box should appear
	similar to the following in the az35, el25 view:
	
	<figure>
	  <title>Wireframe Representation of Globe and Display Box</title>
	  <screenshot>
	    <graphic fileref="wirerepglobox.png"/>
	  </screenshot>
	</figure>
      </para>
      
      <para>
	To view contents of the database, type at the Command Window prompt:
	
	<command>ls[Enter]</command>
      </para>
      
      <para>
	You should see cube1.s, cube2.s, and globe1.s listed as shapes you have
	created. To make regions of these shapes, type at the prompt:
	
	<command>r cube1.r u cube1.s - cube2.s[Enter]</command>
	
	<command>r globe1.r u globe1.s[Enter]</command>
      </para>
    </sect1>
    
    <sect1>
      <title>Using the Combination Editor to Assign Material Properties that Make
      the Objects Appear More Realistic</title>
      
      <para>
	Go to Edit and select Combination Editor. In the dialog box, click the
	button next to the Name entry box. Select globe1.r from Select From All or
	Select From All Regions. Double click  on the globe1.r name. Assign this
	region a Shader of cloud. Check the Boolean Expression box to make sure
	the region is made up of u globe1.s. Click on Apply to accept your
	choices. Go to View and select az35, el25.
      </para>
      
      <para>
	Go back to Name and select cube1.r from the Select From All menu. Assign
	this region a Shader of glass. The glass shader is a shortcut to
	individually changing the attributes of the plastic shader to make it
	appear like glass.
      </para>
      
      <para>
	Go to the Color option and enter the values 244 255 255. This will give
	your glass box a light cyan color. Click on Apply to accept your changes.
      </para>
      
      <para>
	Before you can raytrace your design, you need to clear the Graphics Window
	by typing Z at the Command Window prompt because both shapes and regions
	are being displayed at this point. Next, type in the Command Window:
	
	<command>draw cube1.r globe1.r[Enter]</command>
      </para>
      
      <para>
	The display box and globe should reappear in the Graphics Window. Go to
	the File menu and select Raytrace. Next, select the white option for
	Background Color. Click on Raytrace.
      </para>
      
      <para>
	Your design should show a light cyan-colored glass cube with a blue globe
	inside. To eliminate the wireframing, go to Framebuffer (in the Raytrace
	Panel) and select Overlay. The display should appear similar to the
	following illustration:
	
	<figure>
	  <title>Raytraced Display Box and Globe</title>
	  <screenshot>
	    <graphic fileref="rtdisboxglobe.png"/>
	  </screenshot>
	</figure>
      </para>
      
      <para>
	To make this design more interesting, you can place the globe on a base.
	Do this by going back to Framebuffer and clicking on Active to deactivate
	the framebuffer. Next, go to the Create menu and select the trc 
	(truncated right cone) under the Cones and Cylinders category. Name the
	shape base1.s. Working from a Front view, go to the Edit menu and select
	Scale. Click the middle mouse button to reduce the trc in size until the
	bottom of it appears to be an appropriate size for the globe base. (You
	may need to increase the size of your Graphics Window or decrease your
	geometry view size to see the bottom of the trc.) Next, reduce the height
	of the shape by selecting Set H from the Edit menu and clicking with the
	middle mouse button. You may need to switch back and forth between these
	two options a few times to get an acceptable size. When finished, however,
	do not click on Accept  yet, as we have more changes to make.
      </para>
    </sect1>
    
    <sect1>
      <title>Moving and Rotating an Object</title>
      <para>
	As with other features in MGED, moving and rotating objects can be
	accomplished in several ways, according to the amount of precision
	desired. As previously described, the Shift Grip functions can be used as
	a quick way to change an object when its exact angle and location do not
	necessarily matter. Alternatively, to achieve greater precision, the
	Translate (move) and Rotate commands under Edit can be selected and
	specific parameter numbers can be entered in the Command Window. In this
	lesson, we will experiment with both methods.
      </para>
      
      <para>
	With your trc still in edit mode and still in a Front view, use the SHIFT
	key and the left mouse button to drag your shape (the bottom of the base)
	and sit it on the floor of the cube (just touching the inside box). Note
	that you could have selected Translate under Edit and entered parameters
	on the Command Line to move the trc to an exact location; however, in this
	case, aligning the shape with the drag-and-drop "eyeballing" method was
	appropriate. At this point, you may notice that your trc needs to be
	resized a little to better fit the globe. Use Scale and Set H as needed 
	and then Accept your changes.
      </para>
      
      <para>
	Now we need to make a second trc named base2.s, which we will use for the
	top of the base. On the Command Line, type:
	
	<command>cp base1.s base2.s</command>
      </para>
      
      <para>
	The second trc will appear directly on top of the first trc, so we will
	have to use Primitive Selection under the edit menu to put base2.s in edit
	mode so that we can flip it upside down and then drag it to the top of the
	first trc.
      </para>
      
      <para>
	To do this, we could use  the CTRL and ALT (constrained rotation) keys and
	left mouse button and then move the mouse up or down until the trc is
	upside down. (If this method is used, note that you can release the mouse
	button and regrab the object if you need to.) However, because we know we
	want to rotate the shape an exact amount (180'0) about the x axis, let's
	use a more precise method to flip the shape. Select Rotate under Edit and
	then type in the following parameters (abbreviated as p) on the Command
	Line:
	
	<command>p 180 0 0[Enter]</command>
      </para>
      
      <para>
	Our shape should have flipped upside down and jumped to the bottom of the
	first trc. (The two zeros you input indicate no rotation along the y and z
	axes.) Now use the SHIFT key and the left mouse button to drag base2.s
	upward and sit it on top of base1.s. The two shapes should form a base in
	which to hold your globe. Check your alignment using multiple views and
	then Accept your changes.
      </para>
      
      <para>
	Go to Edit and Primitive Selection and click on globe1.r/globe1.s. As you
	did with the trc shapes, use the Shift Grips to drag the globe down until
	it is in place on the base. Go back to Edit and click on Accept. Your
	design should look as follows:
	
	<figure>
	  <title>Wireframe Representation of Globe and Base in Display Box</title>
	  <screenshot>
	    <graphic fileref="wireglobebasedispbox.png"/>
	  </screenshot>
	</figure>
      </para>
      
      <para>
	To make a region of the base, type in the Command Window:
	
	<command>r base1.r u base1.s u base2.s[Enter]</command>
      </para>
    </sect1>
    
    <sect1>
      <title>Use the Color Tool of the Combination Editor to Produce Customized
      Colors.</title>
      
      <para>
	In the Combination Editor window, click the button  to the right of the
	Name entry box and then Select From All. Choose base1.r. Assign the base a
	Shader of plastic. In the Color box, enter the numbers:
	
	<command>217 217 217</command>
      </para>
      
      <para>
	Apply your changes. Before you can raytrace your completed design, you
	must first clear the Graphics Window and rebuild your design by typing at
	the Command Window prompt:
	
	<command>Z[Enter]</command>
	
	<command>draw cube1.r globe1.r base1.r[Enter]</command>
      </para>
      
      <para>
	Change your view to az35, el25 and then raytrace your design, which should
	appear similar to the following:
      </para>
    </sect1>
    
    <sect1>
      <title>Review</title>
      <para>
	In this lesson, you:
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Used the GUI to create a display box using arb8 shapes.</para>
	  </listitem>
	  <listitem>
	    <para>Created a globe inside the display box.</para>
	  </listitem>
	  <listitem>
	    <para>Used the Combination Editor to assign material properties that make the objects appear more realistic.</para>
	  </listitem>
	  <listitem>
	    <para>Rotated an object 180'0 using the rotate option of the Edit menu.</para>
	  </listitem>
	  <listitem>
	    <para>Used the color option of the Combination Editor to produce customized colors.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter>
  
  <chapter id="Lesson-10">
    <title>Creating a Mug</title>
    <para>
      In this lesson, you will:
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Create an outside cylinder using the in command.</para>
	</listitem>
	<listitem>
	  <para>Create an inside cylinder for hollowing out the larger shape cylinder.</para>
	</listitem>
	<listitem>
	  <para>Create a handle for your mug.</para>
	</listitem>
	<listitem>
	  <para>Create a combination to produce the body of your mug.</para>
	</listitem>
	<listitem>
	  <para>Create a combination to join the handle to the body.</para>
	</listitem>
	<listitem>
	  <para>Create a region of combined shapes with the same material and color.</para>
	</listitem>
      </itemizedlist>
    </para>
    
    <para>
      In this lesson, you will be continuing your work creating real-life
      objects-in this case, the basic body shape of a coffee mug. In the next
      lesson, you will refine the body so that it is more realistic.
    </para>
    
    <sect1>
      <title>Creating a New Database</title>
      <para>
	Create a new database and call it mug.g. Go back to the File menu and
	select Preferences, then Units, and then inches. This will create your
	body using inches. (Note: You could also do this by typing units in at the
	Command Window prompt.)
      </para>
    </sect1>
    
    <sect1>
      <title>Creating the Outside Cylinder Using the In Command</title>
      <para>
	To begin making the body, you will need to create an outside right
	circular cylinder. At the MGED prompt, type:
	
	<command>in bodyout.s rcc</command>
      </para>
      
      <para>
	The diagram of this command is as follows:
      </para>
      <informaltable>
	<tgroup cols='3'>
	  <tbody>
	    <row>
	      <entry>in</entry>
	      <entry>bodyout.s</entry>
	      <entry>rcc</entry>
	    </row>
	    <row>
	      <entry>Make a shape</entry>
	      <entry>Call it bodyout.s</entry>
	      <entry>The shape type is right circular cylinder</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      
      <para>
	MGED will ask you the following questions about the cylinder you want to
	make. Type in the values given in bold. Make sure you leave spaces between
	variable values.
	
	<command>Enter X, Y, Z of vertex: 0 0 0[Enter]</command>
	
	<command>Enter X, Y, Z of height (H) vector: 0 0 3.5[Enter]</command>
	
	<command>Enter radius: 1.75[Enter]</command>
      </para>
      
      <para>
	Note that the streamlined way to do this would be to type:
	
	<command>in bodyout.s rcc 0 0 0 0 0 3.5 1.75[Enter]</command>
      </para>
      
      <para>
	The diagram of this command is as follows:
      </para>
      <informaltable>
	<tgroup cols='6'>
	  <tbody>
	    <row>
	      <entry>in</entry>
	      <entry>bodyout.s</entry>
	      <entry>rcc</entry>
	      <entry>0 0 0</entry>
	      <entry>0 0 3.5</entry>
	      <entry>1.75</entry>
	    </row>
	    <row>
	      <entry>Make a shape</entry>
	      <entry>Call it bodyout.s</entry>
	      <entry>The shape type is right circular cylinder</entry>
	      <entry>The x, y, and z of vertex is 0 0 0</entry>
	      <entry>The x, y, and z of the height vector is 0 0 3.5</entry>
	      <entry>The radius is 1.75</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      <para>
	A shape of a cylinder, in wireframe form, will appear in the Graphics
	Window.
      </para>
    </sect1>
    <sect1>
      <title>Creating the Inside Cylinder</title>
      <para>
	Using this same method, type in the information for the inside right
	circular cylinder. This cylinder will be used to hollow out the outside
	cylinder. Whenever you are creating a hole in the surface of an object,
	make sure the shape creating the hole protrudes through the surface. This
	will ensure that you don't inadvertently leave a thin film of material
	where the two surfaces meet.
	
	<command>in bodyin.s rcc 0 0 0.25 0 0 3.5 1.5[Enter]</command>
      </para>
      
      <para>
	The diagram of this command is:
      </para>
      <informaltable>
	<tgroup cols='6'>
	  <tbody>
	    <row>
	      <entry>in</entry>
	      <entry>bodyin.s</entry>
	      <entry>rcc</entry>
	      <entry>0 0 0.25</entry>
	      <entry>0 0 3.5</entry>
	      <entry>1.5</entry>
	    </row>
	    <row>
	      <entry>Make a shape</entry>
	      <entry>Call it bodyin.s</entry>
	      <entry>The shape type is right circular cylinder</entry>
	      <entry>The x, y, and z of vertex is 0, 0, and 0.25</entry>
	      <entry>The x, y, and z of the height vector is 0, 0, and 3.5</entry>
	      <entry>The radius is 1.5</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      <para>
	A second cylinder, inside the first cylinder, should now appear in the
	Graphics Window.
      </para>
    </sect1>
    
    <sect1>
      <title>Creating the Handle</title>
      <para>
	Now you will want to enter some information about the body's handle. The
	shape type for the handle is an elliptical torus. At the Command Window
	prompt, type:
	
	<command>in handle.s eto 0 2.5 1.75 1 0 0[Enter]</command>
      </para>
      
      <para>
	The diagram of this command is:
      </para>
      <informaltable>
	<tgroup cols='5'>
	  <tbody>
	    <row>
	      <entry>in</entry>
	      <entry>handle.s</entry>
	      <entry>eto</entry>
	      <entry>0 2.5 1.75</entry>
	      <entry>1 0 0</entry>
	    </row>
	    <row>
	      <entry>Make a shape</entry>
	      <entry>Name it handle.s</entry>
	      <entry>The shape type is elliptical torus</entry>
	      <entry>The x, y, and z of the vertex is 0, 2.5, and 1.75</entry>
	      <entry>The x, y, and z of the normal vector is 1, 0, and 0</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      
      <para>
	The program will ask you to enter more values for the elliptical torus you
	are creating. Type in the values shown in bold.
	
	<command>Enter X, Y, Z, of vector C: .6 0 0[Enter]</command>
	
	<command>Enter radius of revolution, r: 1.45[Enter]</command>
	
	<command>Enter elliptical semi-minor axis, d: 0.2[Enter]</command>
      </para>
      
      <para>
	A doughnut shape should appear on the right-hand side of the body. If you
	look carefully, you can see that about one-third of the elliptical torus
	intersects the body.
      </para>
    </sect1>
    
    <sect1>
      <title>Creating the Bodyout.s-Bodyin.s Combination</title>
      <para>
	The next step is to combine the two cylinders into the body of the mug. To
	do this, type:
	
	<command>comb body.c u bodyout.s - bodyin.s[Enter]</command>
      </para>
      
      <para>
	You have told the program to make the combination body.c out of the union
	of bodyout.s minus bodyin.s.
      </para>
      <informaltable>
	<tgroup cols='6'>
	  <tbody>
	    <row>
	      <entry>comb</entry>
	      <entry>body.c</entry>
	      <entry>u</entry>
	      <entry>bodyout.s</entry>
	      <entry>-</entry>
	      <entry>bodyin.s</entry>
	    </row>
	    <row>
	      <entry>Make a combination</entry>
	      <entry>Call it body.c</entry>
	      <entry>Create a union of</entry>
	      <entry>bodyout.s cylinder</entry>
	      <entry>and subtract</entry>
	      <entry>bodyin.s cylinder</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      
    </sect1>
    
    <sect1>
      <title>Creating the Handle.s - Bodyout.s Combination</title>
      <para>
	To combine the handle with the outside cylinder, type:
	
	<command>comb handle.c u handle.s - bodyout.s[Enter]</command>
      </para>
      <informaltable>
	<tgroup cols='6'>
	  <tbody>
	    <row>
	      <entry>comb</entry>
	      <entry>handle.c</entry>
	      <entry>u</entry>
	      <entry>handle.s</entry>
	      <entry>-</entry>
	      <entry>bodyout.s</entry>
	    </row>
	    <row>
	      <entry>Make a combination</entry>
	      <entry>Call it handle.c</entry>
	      <entry>Create a union of</entry>
	      <entry>the handle.s torus</entry>
	      <entry>and subtract</entry>
	      <entry>the bodyout.s cylinder</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect1>
    
    <sect1>
      <title>Creating the Region Mug.r</title>
      
      <para>
	The last step, of this part of making the mug is to make a region out of
	your combinations. Type:
	
	<command>r mug.r u body.c u handle.c[Enter]</command>
      </para>
      <informaltable>
	<tgroup cols='6'>
	  <tbody>
	    <row>
	      <entry>r</entry>
	      <entry>mug.r</entry>
	      <entry>u</entry>
	      <entry>body.c</entry>
	      <entry>u</entry>
	      <entry>handle.c</entry>
	    </row>
	    <row>
	      <entry>Make a region of shapes of the same material and color</entry>
	      <entry>Call it mug.r</entry>
	      <entry>Create a union of</entry>
	      <entry>the body.c combination</entry>
	      <entry>and merge it with</entry>
	      <entry>the handle.c combination</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      
      <para>
	If you did this correctly, the program should say something similar to:
      </para>
      
      <literallayout>
   Defaulting item number to 1002

   Creating region id=1001, air=0, GIFTmaterial=1, los=100
      </literallayout>
      
      <figure>
	<title>Wireframe Mug</title>
	<screenshot>
	  <graphic fileref="wiremug.png"/>
	</screenshot>
      </figure>
      
      <para>
	You should now have the region mug.r that is a combination of shapes
	containing the same material and color. You could assign color and
	material at this point, but you will want to do some more work on this
	design to make it more realistic. So, for now, review the lessons of this
	chapter. When you are ready to work again, you can continue refining your
	design in the next lesson.
      </para>
      
    </sect1>
    
    <sect1>
      <title>Review</title>
      <para>
	In this lesson you:
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Created an outside cylinder using the in command.</para>
	  </listitem>
	  <listitem>
	    <para>Created an inside cylinder for hollowing out the larger shape cylinder.</para>
	  </listitem>
	  <listitem>
	    <para>Created a handle for your mug.</para>
	  </listitem>
	  <listitem>
	    <para>Created a combination to produce the body of your mug.</para>
	  </listitem>
	  <listitem>
	    <para>Created a combination to join the handle to the body.</para>
	  </listitem>
	  <listitem>
	    <para>Created a region of combined shapes with the same material and color.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter>

  <chapter id="Lesson-11">
    <title>Refining the Mug</title>
    <para>
      In this lesson, you will:
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Assign material properties to the mug using the mater command.</para>
	</listitem>
	<listitem>
	  <para>Refine the mug.</para>
	</listitem>
	<listitem>
	  <para>Combine the shapes.</para>
	</listitem>
      </itemizedlist>
    </para>
    <para>
      In this lesson, you will refine the mug you made in the previous lesson.
      If you stopped at the end of that lesson, open the database mug.g before
      continuing.
    </para>
    <sect1>
      <title>Assigning Material Properties to the Mug Using the <command>mater</command> Command</title>
      <para>
	Assigning material properties to a region can be done with either the
	mater or shader command. The program will respond with a series of
	questions. These concern the various parameters of the shader you select
	to use in rendering the object.
      </para>
      <para>
	The most commonly used shader is the plastic shader, which uses a Phong
	lighting model. Select the plastic shader and set the color to a medium
	shade of green. The dialog in the Command Window should appear as follows:
	
	<command>mged> mater mug.r[Enter]</command>
      </para>
      
      <literallayout>
   Shader =

   Shader? ('del' to delete, CR to skip) plastic[Enter]

   Color = (No color specified)

   Color R G B (0..255)? ('del' to delete, CR to skip)

   32 128 32[Enter]

   Inherit = 0: lower nodes (towards leaves) override

   Inheritance (0|1)? (CR to skip) 0[Enter]
      </literallayout>
      
      <para>
	Enter the appropriate information that is shown in bold font. If you want
	to use the streamlined version, type:
	
	<command>mater mug.r plastic 32 128 32 0[Enter]</command>
      </para>
      <para>
	Diagrammed, this command says:
	<informaltable>
	  <tgroup cols='5'>
	    <tbody>
	      <row>
		<entry>mater</entry>
		<entry>mug.r</entry>
		<entry>plastic</entry>
		<entry>32 128 32</entry>
		<entry>0</entry>
	      </row>
	      <row>
		<entry>Assign material properties to a region</entry>
		<entry>Called mug.r</entry>
		<entry>Make the material plastic</entry>
		<entry>Color the mug green</entry>
		<entry>Turn inheritance off*</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
      
      <note>
	<para>
	  Inheritance is an advanced topic beyond the scope of the present
	  discussion.
	</para>
      </note>
    </sect1>
    <sect1>
      <title>Raytracing the Mug</title>
      <para>
	Open the Raytrace Control Panel and select Raytrace. You should get an
	image of a green mug on a dark background (we use a white background here
	to save printing ink). If your mug is not green, you probably need to
	redraw your wireframe before raytracing.
      </para>
      <figure>
	<title>Raytraced Mug Without Rim</title>
	<screenshot>
	  <graphic fileref="rtmugnorim.png"/>
	</screenshot>
      </figure>
    </sect1>
    
    <sect1>
      <title>Refining the Mug</title>
      <para>
	Now let's improve the cup. Notice that the lip of the cup looks a little
	too squared off. To fix this, you will need to add a rounded top to the
	lip. You can do this by positioning a circular torus shape exactly at the
	top of the cup. Then you can add it to the combination body.c.
      </para>
      
      <para>
	At the MGED prompt, type:
	
	<command>in  rim.s tor 0 0 3.5 0 0 1 1.625 0.125[Enter]</command>
      </para>
      
      <informaltable>
	<tgroup cols='7'>
	  <tbody>
	    <row>
	      <entry>in</entry>
	      <entry>rim.s</entry>
	      <entry>tor</entry>
	      <entry>0 0 3.5</entry>
	      <entry>0 0 1</entry>
	      <entry>1.625</entry>
	      <entry>0.125</entry>
	    </row>
	    <row>
	      <entry>Make a shape</entry>
	      <entry>Call it rim.s</entry>
	      <entry>Make the shape a torus</entry>
	      <entry>With x, y, and z vertices of 0, 0, and 3.5</entry>
	      <entry>With x, y, and z of normal vector being 0, 0, and 1</entry>
	      <entry>Radius 1 is 1.625 inches and</entry>
	      <entry>Radius 2 is 0.125 inches</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect1>
    <sect1>
      <title>Combining the Shapes</title>
      <para>
	To combine the torus with the cup, you will need to type at the prompt:
	
	<command>comb body.c u rim.s[Enter]</command>
      </para>
      <para>
	Now you are faced with a unique situation. The shape rim.s was added to
	the list of objects being displayed when it was created. However, now it
	is also a part of mug.r (via body.c). If you raytrace the current view,
	you will have two copies of this shape. The raytracer will complain that
	they overlap.
      </para>
      <para>
	One way to fix this is to clear the display, redisplay the new, complete
	object, and then raytrace. As discussed previously, the fbclear  command
	in the Raytrace Control Panel clears the framebuffer display, and the Z
	command in the Command Window clears all wireframed objects. You can
	redisplay the objects you want to raytrace with the draw command. Type at
	the prompt:
	
	<command>Z[Enter]</command>
	
	<command>draw mug.r[Enter]</command>
      </para>
      <para>
	Raytrace your mug. It should now look similar to the following.
	
	<figure>
	  <title>The Mug Made Through the Command Line</title>
	  <screenshot>
	    <graphic fileref="mugcommandline.png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    
    <sect1>
      <title>Review</title>
      <para>
	In this chapter, you:
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Assigned material properties to the mug using the mater command.</para>
	  </listitem>
	  <listitem>
	    <para>Refined the mug by smoothing the lip.</para>
	  </listitem>
	  <listitem>
	    <para>Combined the shapes.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter>

  <chapter id="Lesson-12">
    <title>Creating the Mug Through the GUI</title>
    <para>
      In this lesson, you will:
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Create the shapes of the mug through the GUI.</para>
	</listitem>
	<listitem>
	  <para>Use new shapes to create the handle and rim of the mug.</para>
	</listitem>
	<listitem>
	  <para>Combine the shapes.</para>
	</listitem>
	<listitem>
	  <para>Make a region of the combinations.</para>
	</listitem>
	<listitem>
	  <para>Check the data tree and make corrections.</para>
	</listitem>
	<listitem>
	  <para>Assign material properties using the Combination Editor.</para>
	</listitem>
      </itemizedlist>
    </para>
    <para>
      In the previous two lessons, you created a mug by entering commands at the
      Command Window prompt. Now, you will create the same type of mug using the
      GUI and different shapes.
    </para>
    <para>
      Begin by opening a new database. Call it mug2.g.
    </para>

    <sect1>
      <title>Creating the Body of the Mug</title>
      <para>
	Go to the Create menu and select rcc (right circular cylinder) under the
	Cones and Cylinders category. Enter the name for the rcc. Call it outside.s.
      </para>
      <para>
	Go to the Edit menu, where you will be offered the following options:
	
	<informaltable>
	  <tgroup cols='4'>
	    <tbody>
	      <row>
		<entry>
		  <literallayout>
		    Set H
		    Set H (Move V)
		    Set A
		    Set B
		    Set c
		    Set d
		    Set A,B
		    Set C,D
		    Set A,B,C,D
		    Rotate H
		    Rotate AxB
		    Move End H(rt)
		    Move End H
		  </literallayout>
		</entry>
		<entry>
		  <literallayout>
		    Rotate
		    Translate
		    Scale
		    None of the Above
		  </literallayout>
		</entry>
		<entry>
		  <literallayout>
		    Reject
		    Accept
		    Apply
		    Reset
		  </literallayout>
		</entry>
		<entry>
		  <literallayout>
		    Primitive Editor
		    Combination
		    Editor
		  </literallayout>
		</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
      <note>
	<para>The first column includes shape-specific functions. The other
	columns are functions common to all shapes.
	</para>
      </note>
      <para>
	Select Set H. From a Front view, move your mouse cursor to the lower half
	of the screen and click the middle mouse button to reduce the scale of the
	cylinder's height. Next select Set A,B,C,D. Move your mouse cursor to the
	upper half of the screen and click the middle mouse button to increase the
	diameter of the cylinder. Accept your changes when your object appears
	similar to the one shown in the following figure.
      </para>
      <note>
	<para>
	  If at any time when you are editing through the GUI you don't  
	  like your changes, you can click on Reject to refuse the changes or   
	  Reset to return the shape to its original form. However, if you       
	  select Reject, you will have to re-enter the Primitive Edit state, as 
	  described in previous lessons.                                        
	</para>
      </note>
      <para>
	Next, create an inside right circular cylinder and name it inside.s. Edit
	the cylinder the same way you edited the outside cylinder. Before you
	accept your changes, change View to Top and make sure your cylinders are
	in alignment. If the cylinders are out of alignment, use the SHIFT key and
	left mouse button to drag the inside cylinder into position. Return your
	View to Front and Accept your changes when the cylinders are lined up.
	Your cylinders should look like those in the following example:
  
	<figure>
	  <title>Two Cylinders Shown from a Front View</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <note>
	<para>
	  Remember that when you scale a shape, the position of the mouse pointer 
	  in the Graphics Window will determine how large or small the  
	  change will be. The closer the mouse pointer is to the center 
	  horizontal line of the window, the smaller the change will be, and 
	  vice versa.                                                        
	</para>
      </note>
    </sect1>

    <sect1>
      <title>Creating the Handle of the Mug</title>

      <para>
	Previously, we made the handle of the mug using an elliptical torus. In
	this lesson, we make the handle by selecting a torus (which is a doughnut
	shape) from the menu of shapes. Name the torus handle.s. The Edit menu
	will now offer a different set of parameters than those of the right
	circular cylinders, as shown in the following list:

	<informaltable>
	  <tgroup cols='4'>
	    <tbody>
	      <row>
		<entry>
		  <literallayout>
		    Set Radius 1
		    Set Radius 2
		  </literallayout>
		</entry>
		<entry>
		  <literallayout>
		    Rotate
		    Translate
		    Scale
		    None of the Above
		  </literallayout>
		</entry>
		<entry>
		  <literallayout>
		    Reject
		    Accept
		    Apply
		    Reset
		  </literallayout>
		</entry>
		<entry>
		  <literallayout>
		    Primitive Editor
		    Combination
		    Editor
		  </literallayout>
		</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
	
	In this instance, Set Radius 1 changes the distance from the center of the
	doughnut hole to the middle of the dough. Set Radius 2 changes the radius
	of the dough ring. With the same technique used in editing the rcc shapes,
	edit the size of the torus until it looks similar to the following
	examples:
	
	<informaltable>
	  <tgroup cols='2'>
	    <tbody>
	      <row>
		<entry><graphic/></entry>
		<entry><graphic/></entry>
	      </row>
	      <row>
		<entry>Mug and Handle from a Front View</entry>
		<entry>Mug and Handle from a Top View</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	Check your mug from the top to make sure the handle is aligned. Accept
	your changes when you are finished.
      </para>
    </sect1>
    
    <sect1>
      <title>Creating the Rim of the Mug</title>
      
      <para>
	To make the rim of the mug, go to the Create, select tor, and name it
	rim.s. Select the Rotate command and type on the Command Line:
	
	<command>p 0 90 0[Enter]</command>
	
	to rotate the torus on its side (90'0 about the y axis). Then, Scale and
	edit the various parameters of the torus using the front and top views
	until the mug looks similar to the following example. Make sure you Accept
	your changes when you are finished.

	<figure>
	  <title>Mug with Rim Shown from a Front View</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    
    <sect1>
      <title>Creating Combinations of the Various Shapes</title>

      <para>
	To combine the various shapes of the mug, type the following commands at
	the Command Window prompt:
	
	<command>comb mug.c u outside.s - inside.s[Enter]</command>
	
	<command>comb handle.c u handle.s - outside.s[Enter]</command>
	
	<command>comb mug.c u rim.s[Enter]</command>
	
	Note: Refer to the previous two lessons to recall how each of these
	commands works.
	
      </para>
    </sect1>

    <sect1>
      <title>Making a Region of the Combinations</title>

      <para>
	To make a region out of the combinations you just created, type at the
	Command Window prompt:
	
	<command>r mug.r u mug.c u handle.c[Enter]</command>
      </para>
    </sect1>

    <sect1>
      <title>Checking the Data Tree</title>

      <para>
	Before continuing, it would be wise to check your data tree and make sure
	it agrees with the following tree:

	<literallayout>
   mug.r/R

   u mug.c/

   u outside.s

   - inside.s

   u rim.s

   u handle.c/

   u handle.s

   - outside.s
	</literallayout>

	If your data tree doesn't look like this example, you will need to go back
	and figure out where you went wrong. If necessary, you can kill off a
	shape, combination, or region by typing at the Command Window prompt:
	
	<command>kill [name of shape, combination, or region][Enter]</command>

      </para>
      <para>
	
	For example, in this lesson you may have created an extra shape, named
	rim2.s, which you no longer want. To kill this shape, you would type:
	
	<command>kill rim2.s[Enter]</command>
	
      </para>
    </sect1>
    <sect1>
      <title>Assigning Material Properties Using the Combination Editor</title>

      <para>
	Go to the Edit menu and select Combination Editor. Type mug.r in the Name
	entry box. Press ENTER. Type 0 148 0 in the Color entry box. Select a
	plastic shader. Check the Boolean Expression box to make sure it says:
	
	<literallayout>
   u mug.c

   u handle.c
	</literallayout>
	
	When you are finished, click on Apply and then Dismiss. In the Command
	Window then, type at the prompt:
	
	<command>B mug.r[Enter]</command>

      </para>
    </sect1>

    <sect1>
      <title>Raytracing the Design</title>
      <para>
	Go to the View option of the menu bar and select az35, el25. Go to File
	and then Raytrace. Select a white background color and Raytrace your
	design. Click on Overlay. When the raytracing is finished, it should look
	like the following example:

	<figure>
	  <title>The Completed Raytraced Mug</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>

    <sect1>
      <title>Review</title>
      <para>
	In this lesson, you:
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Created the shapes of the mug through the GUI.</para>
	  </listitem>
	  <listitem>
	    <para>Used new shapes to create the handle and rim of the mug.</para>
	  </listitem>
	  <listitem>
	    <para>Combined the shapes.</para>
	  </listitem>
	  <listitem>
	    <para>Made a region of the combinations.</para>
	  </listitem>
	  <listitem>
	    <para>Checked the data tree and made corrections.</para>
	  </listitem>
	  <listitem>
	    <para>Assigned material properties using the Combination Editor.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter>
 
  <chapter id="lesson-13">
    <title>Placing Shapes in 3-D Space</title>
    <para>
      In this lesson, you will:
      
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Create, edit, and place shapes in 3-D space.</para>
	</listitem>
	<listitem>
	  <para>Create custom colors using the Combination Editor.</para>
	</listitem>
	<listitem>
	  <para>Identify the attributes of the checker shader.</para>
	</listitem>
	<listitem>
	  <para>Identify how RGB colors are created.</para>
	</listitem>
      </itemizedlist>

    </para>

    <para> 
      In previous lessons, you created and edited shapes. You also placed
      objects in three-dimensional space. This lesson will provide more advanced
      practice on creating and editing shapes and placing them in 3-D space.
    </para>
    <para>
      The design you will make in this lesson is a simple candle in a candle
      holder sitting on a table (as shown in the following figure). In the next
      lesson, you will add decorations and lighting to make the design more
      realistic.
      
      <figure>
	<title>The Candle Design</title>
	<screenshot>
	  <graphic fileref=".png"/>
	</screenshot>
      </figure>
    </para>
    <para>
      Begin by creating a new database called candle.g. Title your database
      Candle Tutorial.
    </para>

    <sect1>
      <title>Creating the Tabletop</title>
      <para>
	Create an arb8 from the GUI. Name the shape arb8.s. Go to View and select
	Front.
      </para>
      <para>
	Go to the Edit option of the menu bar. The arb8 needs to be made larger,
	so, under the Edit menu, select Scale. Put the mouse pointer in the upper
	half of the screen to make the arb8 larger and click the middle mouse
	button until the sides of the arb8 touch each side of the screen. Use the
	SHIFT key and left mouse button to drag the arb into position, if
	necessary.
      </para>
      <para>
	Under the Edit menu, select Move Faces and then Move Face 4378. Place the
	mouse pointer in the lower  half of the screen and click the middle mouse
	button until the arb8 is about the thickness of a tabletop. Go back to
	Edit and Accept the changes, and then use the SHIFT and any mouse key to
	position the tabletop so that it appears similar to the following:
   
	<figure>
	  <title>Wireframe Representation of Tabletop from Front View</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>

      </para>
      <para>
	Make a region of the tabletop by typing at the Command Window prompt:
	
	<command>r table1.r u arb8.s[Enter]</command>
      </para>
    </sect1>
    <sect1>
      <title>Creating the Candle Base</title>
      <para>
	Create an eto and name it eto1.s. To create the bottom of the candle base,
	you will need to flip the eto 180'0. Type at the Command Window prompt:
	
	<command>rot 0 180 0[Enter]</command>
	
	This tells MGED to rotate the shape 180'0 along the y axis. Next, select
	Scale and make the eto a little smaller than its default size. Place the
	eto on the tabletop by using the SHIFT key and left mouse button to drag
	the base into position.
      </para>

      <para>
	View your design from different angles to make sure the eto sits flush on
	the center of the tabletop. Click on Accept when you are satisfied with
	its size and placement. Your base should be similar to the one shown as
	follows:
	
	<figure>
	  <title>Wireframe Representation of Tabletop and First eto</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <para>
	The next step in creating a candle base is to make a right circular
	cylinder (rcc). Name the shape rcc1.s.
      </para>
      <para>
	Go to Edit. In addition to the standard commands, you will be presented
	with a menu of thirteen shape-specific ways to edit this shape.
	<informaltable>
	  <tgroup cols='2'>
	    <tbody>
	      <row>
		<entry>
		  <literallayout>
Set H
Set H (Move V)
Set A
Set B
Set c
Set d
		  </literallayout>
		</entry>
		<entry>
		  <literallayout>
Set A,B
Set C,D
Set A,B,C,D
Rotate H
Rotate AxB
Move End H(rt)
Move End H
		  </literallayout>
		</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>

      <para>
	Scale the shape until it is slightly larger in diameter than the top of
	the eto1.s (you can check this by switching to a top view). Go back to
	Edit and select Set H. Reduce the height of the shape until the rcc is
	about two times the height of eto1.s. Position the cylinder on the
	candle-holder base. Check the placement of the rcc from the top, left, and
	front to ensure that it is centered in the eto. Make sure the bottom of
	the rcc is not quite touching the tabletop. Accept your changes. When
	done, your design should look like the following:

	<figure>
	  <title>Wireframe Representation of Tabletop, First eto and First rcc</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>

      <para>
	The last step in making the candle base is to create another eto. Name it
	eto2.s. Edit this shape as you did the previous eto and place it on top of
	the rcc, as shown in the following figure. Accept your changes when
	finished. Your candle base should now look like this:
	
	<figure>
	  <title>Wireframe Representation of Tabletop and Candle Base</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <para>
	Make a region of the three shapes of the base. Name it base1.r. Your
	Boolean expression should read:
	
	<command>r base1.r u eto1.s u rcc1.s u eto2.s</command>
	
	Note that we could have written it
	
	<command>r base1.r u eto1.s u eto2.s u rcc1.s</command>
	
	but the first expression is preferred to be consistent with the order of a
	later example. In a moment, we will want to remove some material that
	eto2.s gives us. By placing eto2.s last in the list, we can perform this
	removal easily.
      </para>
    </sect1>
    <sect1>
      <title>Creating the Candle</title>
      <para>
	Create an rcc and name it rcc2.s. Edit the shape as you did the previous
	rcc. When you are done, it should look similar to the one in the following
	illustration. (Note: After you have accepted the changes, you can get all
	of your tabletop and candle in the Graphics Window by using the SHIFT key
	and left mouse button to move your view of the design.)
	
	<figure>
	  <title>Wireframe Representation of Tabletop, Candle Base, and Candle</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <para>
	Make a region of the candle. Your Boolean statement should read:
	
	<command>r candle1.r u rcc2.s</command>
	
	Now we create a cylindrical cutout in the base for the candle to sit in.
	To do this we can use the shape of the candle, as follows:
	
	<command>r base1.r - rcc2.s</command>
	
	Earlier we had mentioned that we would want to remove some material that
	we got from eto2.s. Now we have done it.
      </para>
    </sect1>

    <sect1>
      <title>Creating the Candle Flame</title>

      <para>
	Create a particle (part) and name it part1.s. Edit and position the shape
	until your design looks like the following one:
  
	<figure>
	  <title>Wireframe Representation of Completed Candle Design</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>

	Make a region of the flame by typing at the Command Window prompt:
	
	<command>r flame1.r u part1.s[Enter]</command>
      </para>
    </sect1>
    
    <sect1>
      <title>Making a Combination of the Base, Candle, and Flame</title>

      <para>
	To make a combination of the parts of the candle, type at the Command
	Window prompt:
	
	<command>comb candle1.c u base1.r u candle1.r u flame1.r[Enter]</command>
      </para>
    </sect1>
    <sect1>
      <title>Checking the Data Tree</title>
      <para>
	Now that you have made a number of regions and a combination, it would be
	a good time to check your data tree and make sure it agrees with the
	following tree. If you find that you have made a mistake in any of the
	parts of the tree, you can change them in the Boolean Expression box of
	the Combination Editor (refer to Lesson 5). At the Command Line prompt,
	type:
	
	<command>tree candle1.c[Enter]</command>
	
	Your Boolean expression should read:
	
	<literallayout>
   candle1.c/
	
   u base1.r/R

   u eto1.s

   u rcc1.s

   u eto2.s

   - rcc2.s

   u candle1.r/R

   u rcc2.s

   u flame1.r/R

   u part1.s
	</literallayout>
      </para>
    </sect1>
    <sect1>
      <title>Assigning Material Properties to the Elements of the Design</title>
      <para>
	To assign material properties to your design, go to the Edit menu and
	select the Combination Editor. Assign the following material properties to
	each of the elements:
	
	<informaltable frame="all">
	  <tgroup cols='4'>
	    <thead>
	      <row>
		<entry>Element</entry>
		<entry>Shader</entry>
		<entry>Color(s)</entry>
		<entry>Other</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Tabletop</entry>
		<entry>Checker</entry>
		<entry>Red (255 0 0); White (255 255 255)</entry>
		<entry>Scale (10)</entry>
	      </row>
	      <row>
		<entry>Candle Base</entry>
		<entry>Plastic</entry>
		<entry>Medium Gray (128 130 144)</entry>
		<entry></entry>
	      </row>
	      <row>
		<entry>Candle</entry>
		<entry>Plastic</entry>
		<entry>Light Blue (0 166 255)</entry>
		<entry></entry>
	      </row>
	      <row>
		<entry>Flame</entry>
		<entry>Plastic</entry>
		<entry>Light Yellow (255 255 190)</entry>
		<entry></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
      <para>
	Notice that the checker shader for the tabletop includes two color values
	and a scale value. Type the values for red, white, and a scale of 10 in
	the boxes, as follows:
	
	<figure>
	  <title>Combination Editor with the Checker Shader Selected</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>

      </para>
      <para>
	For the rest of the elements of the design, use the Color Tool to make the
	colors shown or simply type them in the Color text box, remembering to
	leave a space between each set of numbers.
      </para>

      <note>
	<para>
	  As discussed previously, a color is made up of three numbers, ranging 
	  from 0 to 255. The first number represents the amount of red, the     
	  second represents the amount of green, and the third represents the   
	  amount of blue used to make the color. A color of 0 0 0 is black, and 
	  255 255 255 is white. This method of creating colors is different     
	  from mixing pigment colors used in painting because you are dealing   
	  with light. While it may seem strange at first, most MGED users       
	  quickly become adept at creating RGB colors.                          
	</para>
      </note>
    </sect1>
    <sect1>
      <title>Raytracing Your Design</title>
      
      <para>
	Before raytracing, change the View to az35, el25 to give a better view of
	the completed design and then Blast the old design by typing at the
	Command Window prompt:
	
	<command>B table1.r candle1.c[Enter]</command>
	
	This command tells the MGED program to:
	<informaltable>
	  <tgroup cols='3'>
	    <tbody>
	      <row>
		<entry>B</entry>
		<entry>table1.r</entry>
		<entry>candle1.c</entry>
	      </row>
	      <row>
		<entry>Clear the Graphics Window</entry>
		<entry>Draw the region named table1.r</entry>
		<entry>Draw the combination named candle1.c</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
      <para>
	To provide the most light on your design, use a white background color.
	Your raytraced candle should look similar to the following:
	
	<figure>
	  <title>Raytraced Candle Design in Overlay Mode</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    <sect1>
      <title>Review</title>
      <para>
	
	In this lesson, you:
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Created, edited, and placed shapes in 3-D space.</para>
	  </listitem>
	  <listitem>
	    <para>Created custom colors using the Combination Editor.</para>
	  </listitem>
	  <listitem>
	    <para>Identified the attributes of the checker shader.</para>
	  </listitem>
	  <listitem>
	    <para>Identified how RGB colors are created.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter>

  <chapter id="lesson-14">
    <title>Gaining More Practice Placing Shapes in Space</title>
    <para>
      In this lesson, you will:
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Create copies of a shape using the Primitive Editor.</para>
	</listitem>
	<listitem>
	  <para>Draw a grid to help position objects.</para>
	</listitem>
	<listitem>
	  <para>Check the data tree and make corrections (if needed).</para>
	</listitem>
	<listitem>
	  <para>Assign material properties using the Combination Editor.</para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      In previous lessons, we created and edited shapes and placed objects in
      3-D space. This lesson provides more advanced practice in these areas
      using the candle design you created in the last lesson.
    </para>
    
    <para>
      Open the candle.g database if it isn't already open and draw candle1.c.
    </para>

    <sect1>
      <title>Making the First Sphere</title>
      
      <para>
	Using the GUI, create a sphere named sph1.s. Go to the View menu and
	select Top view. Go to the Edit menu, select Scale, and size the sphere
	until it is proportionally about the same size as the one in the following
	illustration:
	
	<figure>
	  <title>Sphere Placed on Candle Base from Top View</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    <sect1>
      <title>Using the Draw Grid Feature</title>
      
      <para>
	Drag the sphere into position on the rcc, as shown in the previous
	illustration. To make this task a little easier, you can go to the Modes
	menu and click on Draw Grid. This will create a grid overlay in the
	Graphics Window, which can help you position your spheres on the candle
	base.
      </para>
    </sect1>
    <sect1>
      <title>Using the Multipane Feature</title>
      <para>
	As discussed earlier, another feature that is available to help you
	position each sphere is the Multipane  option under the Modes  menu. This
	will allow you to see multiple views of the design you are creating.
   
	<figure>
	  <title>Multipane Feature</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <para>
	As you move a shape, the change in position will be reflected in each
	pane. The multipanes help you visualize where the shape is in 3-D space.
	In the default mode, the top left pane shows the top view, the top right
	pane shows the current view, the bottom left pane shows the front view,
	and the bottom right pane shows the left view. To turn off either the grid
	or the multipane functions, go back to Modes and click on the feature you
	want to disable.
      </para>
    </sect1>
    <sect1>
      <title>Creating Copies of a Shape</title>
      <para>
	To make more jewels for the base, you could use the copy command on the
	Command Line (cp sph1.s sph2.s), but another way to do this is to go to
	the Edit menu and select Primitive Editor. Type sph1.s in the text box to
	the right of Name. Click on Reset and then change the name to sph2.s and
	click Apply. Continue doing this until you've made eight jewels. Because
	each of the new spheres is an exact copy of the first sphere, you won't be
	able to see them until you select and then move them.
   
	<figure>
	  <title>The Primitive Editor Dialog Box</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <para>
	To position your new spheres, go to Primitive Selection. A submenu of
	shapes you have created will drop down. Use the scrollbar to the right of
	the list of shapes to access the spheres you have created, as shown in the
	following illustration.
	
	<figure>
	  <title>Drop-Down Menu of Primitives Available Through Primitive Selection</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <para>
	Click on sph2.s and drag it into position. Once you have positioned the
	eight spheres around the rcc, your design should look similar to the
	following ones when viewed from the top and front.
	
	<informaltable>
	  <tgroup cols='2'>
	    <tbody>
	      <row>
		<entry><graphic/></entry>
		<entry><graphic/></entry>
	      </row>
	      <row>
		<entry>Candle from Top View</entry>
		<entry>Candle from Front View</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
      <para>
	Notice from the front view that there appears to only be five spheres
	around the base of the candle, but there are eight spheres when you view
	the design from the top. That is because you are viewing 3-D space on a
	2-D screen and the spheres in the back are behind the ones in the front.
	If you change the view to an az35, el25 view, all of the spheres will
	appear, as shown in the following figure. This is one reason why it is
	important to continually check your design from multiple views. A mistake
	in placement that doesn't appear from one view may be very noticeable from
	another view.
	
	<figure>
	  <title>Candle Viewed from az35, el25</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    <sect1>
      <title>Making Regions of the Spheres</title>
      <para>
	Now that all your spheres are made and in place, it is time to make a
	region of each sphere. To do this, type the following in the Command
	Window:
	
	<command>r sph1.r u sph1.s[Enter]</command>
	
	<command>r sph2.r u sph2.s[Enter]</command>
	
	<command>r sph3.r u sph3.s[Enter]</command>
	
	<command>r sph4.r u sph4.s[Enter]</command>
	
	<command>r sph5.r u sph5.s[Enter]</command>
	
	<command>r sph6.r u sph6.s[Enter]</command>
	
	<command>r sph7.r u sph7.s[Enter]</command>
	
	<command>r sph8.r u sph8.s[Enter]</command>
      </para>

      <note>
	<para>
	  There are three easier ways to make all of the regions. The first     
	  involves typing the first command:                                    
	  
	  <command>r sph1.r u sph1.s[Enter]</command>                           
	  
	  and then using the up arrow to recall this command. Now use the left  
	  arrow to move backward in the Command Line to replace both            
	  occurrences of the number "1" with "2" and press ENTER. Repeat this   
	  for each of the numbers 3 through 8.                                  
	</para>
	<para>
	  The second approach is based upon the fact that the Command Line      
	  interpreter of MGED uses the Tcl/Tk language. This gives us access to 
	  some convenient loop commands. The following will make all of the     
	  regions for us in a single command:                                   
	  
	  <command>foreach i { 1 2 3 4 5 6 7 8 } { [Enter]</command>            
	  
	  <command>r sph$i.r u sph$i.s [Enter]</command>                        
	  
	  <command>}[Enter]  </command>                                         
	</para>
	<para>
	  This is much easier and faster than either of the previous methods.   
	  However, if there were many more spheres (say 1000 or more), then it  
	  might be easier to use a third approach, which employs a different    
	  loop type:                                                            
	  <literallayout>                                              
    for {set i 1} {i `&lt;= 1000} {incr i} {[Enter]                           
                                                                          
    r sph$i.r u sph$i.s [Enter]                                           
                                                                          
    }                                                                     
	  </literallayout>
	</para>
      </note>
      <para>
	Next, go to Edit and then Combination Editor. Select sph1.r from the
	Select From All choice in the pull-down menu  to the right of the Name
	entry box. Assign properties of plastic and the color red and then press
	Apply. We then can go back to the Select From All menu listing and repeat
	this process for the other seven spheres. Alternatively, we could use
	Apply after selecting the appropriate material properties and then type in
	the next sphere's name; however, this method requires the user to remember
	to update the Boolean Expression box (e.g., change u sph1.s to u sph2.s)
	so that the Booleans for one shape are not applied to another shape.
      </para>

      <note>
	<para>
	  Once again, we are performing the same operation multiple times. This 
	  is another good opportunity to use a loop.                            
	  
	  <command>foreach i { 1 2 3 4 5 6 7 8 } {[Enter]</command>             
	  
	  <command>mater sph$i.r "plastic" 255 0 0 0[Enter]</command>           
	  
	  <command>}[Enter]</command>                                           
	</para>
	<para>
	  In general, the graphical interface is good for doing one thing at a  
	  time or doing highly visual operations. Repetitive operations are     
	  best performed using a Command Line interface.                        
	</para>
      </note>
    </sect1>
    <sect1>
      <title>Combining the Spheres with the Candle Base</title>
      <para>
	We are now faced with an important decision. At the moment, the jewels
	overlap a portion of the candle base (specifically, the rcc1.s portion).
	Because two objects cannot occupy the same space, we must decide how to
	resolve this situation. There are two choices:
	
	<itemizedlist>
	  <listitem>
	    <para>
	      We can have perfectly round jewels with dents in the side of the
	      candle base where the jewels are mounted.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      We can have a perfectly round base with a cylindrical bite taken out
	      of the back of each jewel.
	    </para>
	  </listitem>
	</itemizedlist>
	
	For this lesson, we will use the first choice.
      </para>
      <para>
	Now we are faced with a second decision: how to achieve this result. The
	key is that the space the jewels occupy must be subtracted from the
	correct part (rcc1.s) of the base.
      </para>
      <para>
	On the Command Line, create rcc1.c by typing:
	
	<command>comb rcc1.c u rcc1.s - sph1.r - sph2.r - sph3.r - sph4.r - sph5.r - sph6.r
	- sph7.r - sph8.r[Enter]</command>
	
	Next, bring up the Combination Editor and select base1.r. Change the union
	of rcc1.s in the Boolean Expression window to a union of rcc1.c, and click
	OK.
	
	The tree of base1.r should now look like:
	<literallayout>
   u base1.r/R

   u eto1.s

   u rcc1.c

   u rcc1.s

   - sph1.r/R

   u sph1.s

   - sph2.r/R

   u sph2.s

   - sph3.r/R

   u sph3.s

   - sph4.r/R

   u sph4.s

   - sph5.r/R

   u sph5.s

   - sph6.r/R

   u sph6.s

   - sph7.r/R

   u sph7.s

   - sph8.r/R

   u sph8.s

   u eto2.s

   - rcc2.s
	</literallayout>
      </para>
      <note>
	<para>
	  Note that we could have achieved the same results on the Command Line 
	  by using the rm (remove) command to remove rcc1.s from base1.r and    
	  then adding rcc1.c:                                                   
	  
	  <command>rm base1.r rcc1.s[Enter] </command>                          
	  
	  <command>r base1.r u rcc1.c[Enter] </command>                         
	</para>
	<para>
	  This would have resulted in a very similar tree as above:             
	  <literallayout>
    u base1.r/R                                                           
                                                                          
    u eto1.s                                                              
                                                                          
    u eto2.s                                                              
                                                                          
    - rcc2.s                                                              
                                                                          
    u rcc1.c                                                              
                                                                          
    u rcc1.s                                                              
                                                                          
    - sph1.r/R                                                            
                                                                          
    u sph1.s                                                              
                                                                          
    - sph2.r/R                                                            
                                                                          
    u sph2.s                                                              
                                                                          
    - sph3.r/R                                                            
                                                                          
    u sph3.s                                                              
                                                                          
    - sph4.r/R                                                            
                                                                          
    u sph4.s                                                              
                                                                          
    - sph5.r/R                                                            
                                                                          
    u sph5.s                                                              
                                                                          
    - sph6.r/R                                                            
                                                                          
    u sph6.s                                                              
                                                                          
    - sph7.r/R                                                            
                                                                          
    u sph7.s                                                              
                                                                          
    - sph8.r/R                                                            
                                                                          
    u sph8.s                                                              
	  </literallayout>
	</para>
	<para>
	  Finally, we could have avoided making an intermediate object in the   
	  database by moving rcc1.s to the end of the Boolean equation for      
	  base1.r and then subtracting each of the jewels from base1.r (hence,  
	  removing material from rcc1.s). This would have resulted in:          
	  
	  <literallayout>
    u base1.r/R                                                           
                                                                          
    u eto1.s                                                              
                                                                          
    u eto2.s                                                              
                                                                          
    - rcc2.s                                                              
                                                                          
    u rcc1.s                                                              
                                                                          
    - sph1.r/R                                                            
                                                                          
    u sph1.s                                                              
                                                                          
    - sph2.r/R                                                            
                                                                          
    u sph2.s                                                              
                                                                          
    - sph3.r/R                                                            
                                                                          
    u sph3.s                                                              
                                                                          
    - sph4.r/R                                                            
                                                                          
    u sph4.s                                                              
                                                                          
    - sph5.r/R                                                            
                                                                          
    u sph5.s                                                              
                                                                          
    - sph6.r/R                                                            
                                                                          
    u sph6.s                                                              
                                                                          
    - sph7.r/R                                                            
                                                                          
    u sph7.s                                                              
                                                                          
    - sph8.r/R                                                            
                                                                          
    u sph8.s                                                              
	  </literallayout>
	</para>
	<para>
	  It would be good practice to consider the relative merits of each of  
	  the approaches discussed.                                            
	</para>
      </note>
      <para>
	Now we need to add the jewels to the whole of candle1.c:
	
	<command>comb candle1.c u sph1.r u sph2.r u sph3.r u sph4.r u sph5.r u sph6.r u
	sph7.r u sph8.r[Enter]</command>
      </para>
      <para>
	There are just a couple of things left to do before you raytrace your
	design. If you have enabled Multipanes or Draw Grid, go back to the Modes
	menu and disable them. Then, clear your screen and draw your new design by
	typing in the Command Window:
	
	<command>B candle1.c table1.r</command>
	
	Your new design should appear in the Graphics Window. Open the  Raytrace
	Control Panel and select a pale blue color (200 236 242) by typing the
	three values in the Background Color entry box. When you raytrace your
	design, it should look similar to the following one:
	
	<figure>
	  <title>Raytraced Candle with Jeweled Base</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
	
      </para>
    </sect1>
    <sect1>
      <title>Review</title>
      <para>
	In this lesson, you:
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Created copies of a shape using the Primitive Editor.</para>
	  </listitem>
	  <listitem>
	    <para>Drew a grid to help position objects.</para>
	  </listitem>
	  <listitem>
	    <para>Checked the data tree and made corrections (if needed).</para>
	  </listitem>
	  <listitem>
	    <para>Assigned material properties using the Combination Editor.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter>

  <chapter id="lesson-15">
    <title>Creating a Toy Truck</title>
    <para>
      In this lesson, you will:
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Create a toy truck from three shapes.</para>
	</listitem>
	<listitem>
	  <para>Make copies of shapes using the Primitive Editor.</para>
	</listitem>
	<listitem>
	  <para>Make combinations and regions of a more complex object.</para>
	</listitem>
	<listitem>
	  <para>Check the data tree for accuracy.</para>
	</listitem>
	<listitem>
	  <para>List contents of the database.</para>
	</listitem>
	<listitem>
	  <para>Assign material properties using the Combination Editor.</para>
	</listitem>
	<listitem>
	  <para>Identify the difference between OK, Accept, Apply, Reset, Cancel, and Dismiss.</para>
	</listitem>
	<listitem>
	  <para>Identify the on-screen help option.</para>
	</listitem>
	<listitem>
	  <para>Identify the stacker option.</para>
	</listitem>
	<listitem>
	  <para>Experiment with the attributes of the camo shader.</para>
	</listitem>
      </itemizedlist>
    </para>
    <para>
      In previous lessons, you created and edited shapes to produce simple
      objects. This lesson focuses on creating a slightly more complex object, a
      toy truck, from the Command Window. Your completed truck should look
      similar to the following truck:
      
      <figure>
	<title>Raytraced Toy Truck Design</title>
	<screenshot>
	  <graphic fileref=".png"/>
	</screenshot>
      </figure>

    </para>
    <para>
      Begin by creating a new database called truck.g.
    </para>
    <sect1>
      <title>Creating an rpp for the Cab of the Truck Using the In Command</title>
      <para>
	To make the cab of the truck, you will create a right parallel piped using
	the in (insert) command. At the Command Window prompt, type:
	
	<command>in cab1.s rpp[Enter]</command>
	
	MGED will ask you to enter values for XMIN, XMAX, YMIN, YMAX, ZMIN, and
	ZMAX. Type at the prompt:
	
	<command>0 1 0 1 0 1[Enter]</command>
	
	This will tell MGED to:
	<informaltable>
	  <tgroup cols='6'>
	    <tbody>
	      <row>
		<entry>0</entry>
		<entry>1</entry>
		<entry>0</entry>
		<entry>1</entry>
		<entry>0</entry>
		<entry>1</entry>
	      </row>
	      <row>
		<entry>Make the value of the rpp's XMIN 0</entry>
		<entry>Make the value of the rpp's XMAX 1</entry>
		<entry>Make the value of the rpp's YMIN 0</entry>
		<entry>Make the value of the rpp's YMAX 1</entry>
		<entry>Make the value of the rpp's ZMIN 0</entry>
		<entry>Make the value of the rpp's ZMAX 1</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
      <para>
	You could also have used the streamlined version of:
	
	<command>in cab1.s rpp 0 1 0 1 0 1[Enter]</command>
	
	A cube shape should appear in the Graphics Window, as follows:
	
	<figure>
	  <title>Wireframe Representation of Shape cab1.s</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>

      </para>
    </sect1>
    <sect1>
      <title>Using the Inside Command to Create an rpp for the Hood of the Cab</title>
      <para>
	To make the hood of the cab, you will need to make another rpp shape, this
	time using the inside command. This special command was originally created
	to hollow out objects such as gas tanks and boxes; however, it can be used
	to create any new shape that has some relationship to a pre-existing
	shape. In this lesson, it is used to cut away material above the hood and
	in front of the cab.
      </para>
      <para>
	If you are using BRL-CAD version 6.0 or later, at the Command Window
	prompt, type:
	
	<command>inside cab1.s caboff1.s .5 -.1 .7 -.1 -.1 -.1[Enter]</command>
	
	The inside command tells MGED to:
	<informaltable>
	  <tgroup cols='9'>
	    <tbody>
	      <row>
		<entry>inside</entry>
		<entry>cab1.s</entry>
		<entry>caboff1.s</entry>
		<entry>.5</entry>
		<entry>-.1</entry>
		<entry>7</entry>
		<entry>-.1</entry>
		<entry>-.1</entry>
		<entry>-.1</entry>
	      </row>
	      <row>
		<entry>Inside the shape</entry>
		<entry>named cab1.s,</entry>
		<entry>create rpp called caboff1.s</entry>
		<entry>Make face 1234 (bottom) .5 units thick</entry>
		<entry>Make face 5678 (top) -.1 units thick</entry>
		<entry>Make face 1485 (rear) .7 units thick</entry>
		<entry>Make face 2376 (front) -.1 units thick</entry>
		<entry>Make face 1265 (right) -.1 units thick</entry>
		<entry>Make face 3478 (left) -.1 units thick</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
	
      </para>
      <note>
	<para>
	  In this example, each negative thickness number indicates that
	  caboff1.s will protrude through the corresponding face of cab1.s.
	</para>
      </note>
      <note>
	<para>
	  Note that in BRL-CAD versions 6.0 and later, the faces of an rpp are  
	  numbered in a different order than in previous versions. So, if you   
	  are using a pre-6.0 release of the package, the following parameter   
	  order must be used for the aforementioned inside command:             
	  
	  <command>inside cab1.s caboff1.s -.1 .7 -.1 -.1 .5 -.1[Enter]</command>
	  
	  (The order of faces in this case is front, rear, right, left, bottom, 
	  top instead of that specified for versions 6.0 and later.)            
	</para>
      </note>
     
      <para>
	When in Multipane mode, the design should resemble the following
	illustration.
	
	<figure>
	  <title>Truck Cab with Cutoff</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    <sect1>
      <title>Using an rcc to Create a Wheel Well in the Cab</title>
      <para>
	Make a cylinder (rcc) to use for cutting away a space for the first wheel
	of the cab. At the Command Window prompt, type:
	
	<command>make well1.s rcc[Enter]</command>
	
	Go to the Edit menu and click on Primitive Selection, then well1.s. After
	selecting a Left view, go back to Edit and select Scale. Reduce the size
	of the rcc until its diameter is about the right size for a wheel well. Go
	back to Edit and select Rotate. As discussed previously, one way to easily
	rotate the rcc is by using the CTRL key and the left mouse button to drag
	the top lip of the rcc down (in a straight line) until the A and C edit
	labels overlap. However, because we know we want to flip the object
	exactly 90'0 along the x axis, a better choice is to use the Command Line
	and type:
	
	<command>p 90 0 0[Enter]</command>
	
	After doing so, you may still have to use the Set H and Scale editing
	options to resize and the SHIFT key and left mouse button to position your
	wheel well. When satisfied, select Accept. Your design should look similar
	to the following in Multipane mode:
	
	<figure>
	  <title>Multipane View of Truck with First Wheel in Place</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    <sect1>
      <title>The Difference Between OK, Accept, Apply, Reset, Cancel, and Dismiss</title>
      <para>
	The GUI environment of MGED offers users several options for applying,
	accepting, or rejecting changes made through buttons at the bottom of
	dialog pop-up windows. To use any of these options, just place the mouse
	cursor over the desired button and click the left mouse button.
      </para>
      <para>
	Selecting the Accept or OK button will tell MGED to record the changes you
	have made to a shape, region, or combination. MGED uses the Accept and OK
	buttons interchangeably. When you click on Accept or OK, the window you
	are using will automatically close.
      </para>
      <para>
	The Apply button tells MGED to apply a change you have made and wait for
	further instructions. The window does not automatically close. This
	enables you to make changes to several things without having to reopen the
	window for each change.
      </para>
      <para>
	The Reset button tells MGED to reset values you have changed in a dialog
	box to the last values you applied or accepted. The Reset button does not
	close the dialog box. The Cancel or Dismiss buttons discard any changes
	made in the dialog box and leave values unchanged from their last stored
	settings. These two buttons close the dialog box.
      </para>
    </sect1>
    <sect1>
      <title>Using the Primitive Editor to Make a Copy of the Wheel Well</title>
      <para>
	To make a copy of your wheel well, go to the Edit menu and select
	Primitive Editor, which will contain information about the last shape
	edited through the dialog box (or myPrimitive if nothing has been edited).
	Erase the old shape's name in the Name entry box. Type in well1.s and
	press Reset (or press Enter while the cursor is still in the Name entry
	box). The parameter values of the old shape will be replaced by those of
	the new shape. The Primitive Editor will change and look something like
	the following example:
	
	<figure>
	  <title>The Primitive Editor</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>

      </para>
      <para>
	Go back to the Name text box and change the 1 to a 2 and click on OK.
	Change to Front under the View menu. Go to Edit/Primitive Selection and
	click on well2.s. Use the SHIFT and left mouse button to drag the new
	wheel well into position, as shown in the following illustration. Check
	your alignment in Multipane mode and then click on Accept when you are
	finished.
	
	<figure>
	  <title>Placement of the Second Wheel</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    <sect1>
      <title>Making a Combination of the Cab Shapes</title>
      <para>
	It is now time to make a combination of the various cab shapes.
	
	<command>comb cab1.c u cab1.s - caboff1.s - well1.s - well2.s[Enter]</command>
	
	This command tells MGED to:
	
	<informaltable>
	  <tgroup cols='10'>
	    <tbody>
	      <row>
		<entry>comb</entry>
		<entry>cab1.c</entry>
		<entry>u</entry>
		<entry>cab1.s</entry>
		<entry>-</entry>
		<entry>caboff1.s</entry>
		<entry>-</entry>
		<entry>well1.s</entry>
		<entry>-</entry>
		<entry>well2.s</entry>
	      </row>
	      <row>
		<entry>Make a combination</entry>
		<entry>Name it cab1.c</entry>
		<entry>Make a union</entry>
		<entry>of the shape cab1.s</entry>
		<entry>minus</entry>
		<entry>the shape caboff1.s</entry>
		<entry>minus</entry>
		<entry>the shape well1.s</entry>
		<entry>minus</entry>
		<entry>the shape well2.s</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
      <para>
	Before you go any further, you should check your data tree by typing tree
	cab1.c. The data tree should say:

	<literallayout>
   cab1.c/

   u cab1.s

   - caboff1.s

   - well1.s

   - well2.s
	</literallayout>
	
      </para>
      <para>
	If you type ls (list) at the Command Window prompt, you should find that
	your database is composed of the combination cab1.c and the shapes cab1.s,
	caboff1.s, well1.s, and well2.s. You will find as you make more complex
	objects that you will periodically refer to the list of the database to
	ensure it is composed of the elements you want.
      </para>
    </sect1>
    <sect1>
      <title>Creating an rpp for the Body of the Truck Using the In Command</title>
      <para>
	To make the body of the truck, type at the Command Window prompt:
	
	<command>in body1.s rpp 0 2 0 1 0 1.5[Enter]</command>
	
	By now, you should know what this command tells MGED to do. If you have
	forgotten, refer back to making the cab of the truck.
      </para>
      <para>
	Edit the body of the truck so that its front face slightly overlaps the
	cab's back face. Check different views to make sure the body lines up
	correctly with the cab. Accept your changes when you are done, and then
	Blast your design. Your truck should now look like the following:
   
	<figure>
	  <title>Truck Cab and Body</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    <sect1>
      <title>Using the Primitive Editor to Make Two More Wheel Wells</title>
      <para>
	To make two wheel wells for the body of the truck, repeat the steps used
	in making the second wheel well. Name your new shapes well3.s and well4.s.
	Using multiple views, move the new shapes into position so that your truck
	now looks similar to the following:
   
	<figure>
	  <title>Wireframe Representation of Truck with Wheel Wells</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>

               Wireframe Representation of Truck with Wheel Wells
      </para>
    </sect1>
    <sect1>
      <title>Making a Combination of the Truck Body and Wheel Wells</title>
      <para>
	Make a combination of the truck body and the two new wheel wells. Name it
	body1.c.
	
	The tree for body1.c should say:
	
	<literallayout>
   body1.c/

   u body1.s

   - well3.s

   - well4.s
	</literallayout>
      </para>
    </sect1>
    <sect1>
      <title>Making a Region of the Cab and Body</title>
      <para>
	Before adding wheels to the truck, you need to make a region of the cab
	and body. At the Command Window prompt, type:
	
	<command>r truck1.r u cab1.c u body1.c[Enter]</command>
      </para>
    </sect1>
    <sect1>
      <title>Making Wheels for the Truck</title>
      <para>
	Perhaps the best shape for making wheels is the torus. You can create a
	shape through the Command Window that has the correct size and placement
	for your design without further editing. However, this lesson is designed
	to give you practice rotating and translating shapes.
      </para>
      <para>
	To make the first wheel, type at the Command Window prompt:
	
	<command>in wheel1.s tor 0 0 0 .5774 .5774 .5774 .18 .08[Enter]</command>
	
	This command tells MGED to:
	<informaltable>
	  <tgroup cols='7'>
	    <tbody>
	      <row>
		<entry>in</entry>
		<entry>wheel1.s</entry>
		<entry>tor</entry>
		<entry>0 0 0</entry>
		<entry>.5774 .5774 .5774</entry>
		<entry>.18</entry>
		<entry>.08</entry>
	      </row>
	      <row>
		<entry>Create a shape</entry>
		<entry>Name it wheel1.s</entry>
		<entry>Make the shape a torus</entry>
		<entry>Make the values of the vertex 0 0 0</entry>
		<entry>Make the values for x, y, and z of the normal vector .5774 .5774 .5774</entry>
		<entry>Make the value of the outer radius .18</entry>
		<entry>Make the value of radius 2 (the tire thickness) .08</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
      <para>
	Change View to Left and then Edit the position of the wheel. To correctly
	align the wheel with the truck, you will have to Rotate the tire using the
	CTRL key and any mouse button. Scale and Translate the wheel into position
	as appropriate and check your alignment from several different views.
	Accept your changes when finished.
      </para>
      <para>
	Using the Primitive Editor, make the second, third, and fourth wheels.
	Move each of these wheels into position until your truck looks like the
	following:
	
	<figure>
	  <title>Wireframe Truck and Wheels</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    <sect1>
      <title>Making a Region of the Wheels</title>
      <para>
	Make a region of the four wheels. When you are finished, your data tree
	for wheel1.r should say:

	<literallayout>
   wheel1.r/R

   u wheel1.s

   u wheel2.s

   u wheel3.s

   u wheel4.s
	</literallayout>
      </para>
    </sect1>
    <sect1>
      <title>Assigning Material Properties to the Truck Regions</title>
      <para>
	Your truck is composed of two regions: truck1.r and wheel1.r. Use the
	Combination Editor and select truck1.r.
      </para>
      <para>
	In the Combination Editor, the camouflage (camo) shader creates a
	pseudo-random tricolor camouflage pattern on the object using a fractal
	noise pattern. The shader offers lots of attributes from which to choose.
	For now, select a Background Color of black (0 0 0) and make Color #1
	green (0 134 0), and Color #2 rust brown (164 96 38). To make the pattern
	design proportional to the truck, select a Noise Size of .25 and then
	Apply the selections. The Combination Editor window for the camo shader
	should look like this:
	
	<figure>
	  <title>Camo Shader</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <para>
	Apply a black color and plastic shader to the wheels (wheel1.r) and click
	on OK. Then raytrace your design.
      </para>
    </sect1>
    <sect1>
      <title>Using the On-Screen Help Option</title>
      <para>
	You have probably noticed that many of the MGED menus offer a wide variety
	of options from which to choose. With so many choices available, it is
	easy to forget what a particular selection does. To help users quickly
	access basic information about the various MGED options, the program
	offers a context-sensitive, on-screen help feature.
      </para>
      <para>
	The on-screen help can be accessed from any menu or pop-up window by
	placing the mouse cursor over the name of any option in the menu or window
	and clicking the right mouse button. The only place this feature doesn't
	work is in the geometry portion of the Graphics Window, where the design
	is drawn.
      </para>
    </sect1>
    <sect1>
      <title>The Stacker Option</title>
      <para>
	In previous lessons, you applied color and a shader to an object to make
	it appear realistic. Sometimes, however, you will need to apply two or
	three shaders to an object to get the design you want.
      </para>
      <para>
	MGED offers three categories of shaders: paint, plastic, and light. Any
	combination of these three types of shaders can be applied to the same
	object using the stacker option of the shader menu.
      </para>
      <para>
	There are three plastic shaders: glass, mirror, and plastic. A plastic
	shader is used to give the perception of space. It does this by making the
	object's surface shiny so that it reflects light. A plastic shader is
	normally applied last in the stacker process.
      </para>
      <para>
	The paint shaders are used to apply pigment and texture to the surface of
	an object. Color is pigment, and texture is the three-dimensional quality
	of the surface material (such as stucco paint).
      </para>
      <para>
	Pigment shaders include camo, texture (color), texture (black/white), fake
	star, cloud, checker, test map, and projection. Texture shaders include
	bump map, fbm bump, and tur bump. Paint shaders are normally applied first
	in the stacking process and are used in combination with the plastic
	shader.
      </para>
      <para>
	The light shader is used to produce illumination in the scene. This helps
	produce realism in the final image. The light shader is technically
	complex and is not discussed in this tutorial.
      </para>
      <para>
	The camo shader involves applying pigments, in a random pattern, to the
	surface of an object. The camo shader doesn't indicate the
	three-dimensional nature of an object. If you want your design to show
	depth, you will need to stack the camo shader and the plastic shader.
      </para>
    </sect1>
    <sect1>
      <title>Using the Stacker Option</title>
      <para>
	To use the stacker option, open the Combination Editor and select
	truck1.r. Click on the button to the right of the Shader entry box and
	then select stack from the drop-down menu. A button with the words Add
	Shader will appear under the text box. Click on the button and then select
	camouflage. Set the Background Color to black (0 0 0), Color #1 to green
	(0 134 0), and Color #2 to rust brown (164 96 38). Make the Noise Size
	.25. Click on Add Shader once again and select plastic.
      </para>
      <para>
	At this point, your Combination Editor window may have gone off the bottom
	of the screen. If this happens, reduce the size of the window as much as
	you can and then drag it up to the top of the screen. The buttons at the
	bottom of the box should now appear, and you can Apply your selections.
      </para>

      <caution>
	<para>
	  When using the stacker option, you need to keep track of the 
	  number of characters and spaces in the shader text box. MGED versions 
	  prior to release 6.0 will only recognize 64 characters/spaces, so be  
	  careful stacking shaders with complex attributes.                     
	</para>
      </caution>
    </sect1>
    <sect1>
      <title>Making a Combination of the Truck Regions</title>
      <para>
	To make a combination of the two truck regions, type at the Command Window
	prompt:
	
	<command>comb truck1.c u truck1.r u wheel1.r[Enter]</command>
	
	<command>B truck1.c[Enter]</command>
	
	Your data tree for truck1.c should read:
	<literallayout>
   truck1.c/

   u truck1.r/R

   u cab1.c/

   u cab1.s

   - caboff1.s

   - well1.s

   - well2.s

   u body1.c

   u body1.s

   - well3.s

   - well4.s

   u wheel1.r/R

   u wheel1.s

   u wheel2.s

   u wheel3.s

   u wheel4.s
	</literallayout>
      </para>
    </sect1>
    <sect1>
      <title>Raytracing the Truck</title>
      <para>
	The last step in creating your truck is to raytrace your design. When the
	raytracer has finished, notice that the top and one side of the truck are
	very dark. This is because there is very little light falling on them.
	Because we have not specified any light sources for our scene, MGED
	provides us with a set of default lights. These defaults consist of a dim
	light at the location of the viewer and a brighter one located to the left
	and below the viewer. Since the primary light is not really shining on one
	side of the truck, it is dark.
      </para>
      <para>
	There is a special adjustment we can make to improve the overall
	brightness of the scene. We can adjust the amount of ambient light, which
	is light that does not come from a particular light source but is a
	measure of the light generally present in the scene. To adjust the amount
	of ambient light, click on the Advanced Settings  button in the Raytrace
	Control Panel. Next to Other Options, type -A .9 and click Dismiss. Now
	when you raytrace, you will get a much lighter image.
      </para>
      <para>
      <informaltable>
	  <tgroup cols='2'>
	    <tbody>
	      <row>
		<entry>
		  <para>
		    <figure>
		      <title>Wireframe Representation of Tabletop, First eto and First rcc</title>
		      <screenshot>
			<graphic fileref=".png"/>
		      </screenshot>
		    </figure>
		  </para>
		</entry>
		<entry>
		  <para>
		    <figure>
		      <title>Wireframe Representation of Tabletop, First eto and First rcc</title>
		      <screenshot>
			<graphic fileref=".png"/>
		      </screenshot>
		    </figure>
		  </para>
		</entry>
	      </row>
	      <row>
		<entry>
		  Truck with Default Lighting
		</entry>
		<entry>
		  Truck with Added Ambient Light
		</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
    </sect1>
    <sect1>
      <title>Review</title>
      <para>
	In this lesson, you:
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Created a toy truck from three shapes.</para>
	  </listitem>
	  <listitem>
	    <para>Made copies of shapes using the Primitive Editor.</para>
	  </listitem>
	  <listitem>
	    <para>Made combinations and regions of a more complex object.</para>
	  </listitem>
	  <listitem>
	    <para>Checked the data tree for accuracy.</para>
	  </listitem>
	  <listitem>
	    <para>Listed contents of the database.</para>
	  </listitem>
	  <listitem>
	    <para>Assigned material properties using the Combination Editor.</para>
	  </listitem>
	  <listitem>
	    <para>Identified the difference between OK, Accept, Apply, Reset, Cancel, and Dismiss.</para>
	  </listitem>
	  <listitem>
	    <para>Identified the on-screen help option.</para>
	  </listitem>
	  <listitem>
	    <para>Identified the stacker option.</para>
	  </listitem>
	  <listitem>
	    <para>Experimented with the attributes of the camo shader.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter>
  <chapter id="lesson-16">
    <title>Learning Modeling Techniques and Structures</title>
    <para>
      In this lesson, you will be:
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Making the shapes of the walkie-talkie radio into regions.</para>
	</listitem>
	<listitem>
	  <para>Gathering the regions into an assembly combination.</para>
	</listitem>
	<listitem>
	  <para>Assigning material properties to the regions.</para>
	</listitem>
	<listitem>
	  <para>Adding internal components to the radio.</para>
	</listitem>
	<listitem>
	  <para>Creating specialty models of the radio.</para>
	</listitem>
	<listitem>
	  <para>Redefining the structure of the radio.</para>
	</listitem>
      </itemizedlist>
    </para>
    <para>
      In Lesson 2, we made the basic shapes of a walkie-talkie radio to gain
      experience in viewing objects. Now that we have successfully modeled a few
      simple objects, let's return to the radio to make it more realistic and,
      in so doing, discuss logical techniques and structures in modeling. When
      finished, our radio should look as follows:

      <figure>
	<title>Walkie-Talkie Radio</title>
	<screenshot>
	  <graphic fileref=".png"/>
	</screenshot>
      </figure>
    </para>
    <sect1>
      <title>Making the Shapes into Regions</title>
      <para>
	Open the database radio.g that you created in Lesson 2. In the Command
	Window, use the ls command to list all the contents of your radio. It
	should read as follows:
	
	<literallayout>
   ant.s btn.s knob.s

   body.s btn2.s spkr.s
	</literallayout>
	
	Now what does this list really contain? Parts to a model radio? Not
	really. What the list actually comprises is just a collection of shapes
	(which we have hinted at by using a .s suffix) that (1) do not have
	material properties, and therefore (2) do not occupy space.
      </para>
      <note>
	<para>
	  Remember, in MGED no shape truly becomes an object until it is        
	  included in a region, which, by definition, is an object or           
	  collection of objects that has a common material type.                
	</para>
      </note>
      <para>
	So our first order of business is to identify the major parts of the radio
	so we can properly define the regions. So far, our choices are fairly
	simple. The radio basically consists of (1) a body, which houses the
	speaker and all of the internal parts; (2) an antenna; (3) a volume
	control knob, and (4) a talk button. These should be our four regions.
      </para>
      <para>
	Most of these shapes were fairly straightforward to create, with each item
	consisting of just one or two primitive shapes. However, if we think of
	the radio as a real-world object, the body of the radio is actually more
	complex than just a solid box with a few shapes glued to its surface.
	(Remember that all objects are solid unless constructed to be otherwise.)
	Therefore, let's start with the main component of the radio-the body.
 
	<figure>
	  <title>The Body of the Radio</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <para>
	If we think about it, the body of a radio is actually a hollow case. So,
	the first thing we need to do is hollow out the case's interior to make
	room for internal components. To do this, we can use the inside command to
	create a shape, which we'll call cavity.s:
	
	<command>inside body.s cavity.s 1 1 1 1 1 1[Enter]</command>
	
	Now, we'll make a region called case.r and define it as what's left of
	body.s after cavity.s has been subtracted out. The command should look
	like this:
	
	<command>r case.r u body.s - cavity.s[Enter]</command>
      </para>
      <note>
	<para>
	  Remember that the inside command was originally created to hollow out 
	  objects such as gas tanks and boxes; however, it can also be used to  
	  create any new cutaway shape that has some relationship to a          
	  pre-existing shape.                                                   
	</para>
      </note>
      <para>
	With our case now made, we can proceed to cut several holes through this
	structure to accommodate the antenna, the volume control knob, and the
	talk button. To do this, we must subtract the three shapes from the case
	as follows:
	
	<command>r case.r - ant.s - knob.s - btn.s[Enter]</command>
	
	Finally, we need to "glue" the lip around the speaker to the case's front
	face by typing
	
	<command>r case.r u spkr.s[Enter]</command>
      </para>
      <para>
	Our body is now finished. Note that an experienced modeler would probably
	have combined the preceding three Boolean functions into a single command
	as follows:
	
	<command>r case.r u body.s - cavity.s - ant.s - knob.s - btn.s u spkr.s[Enter]</command>
	
	If we were to raytrace case.r at this point, we would see the following:
	<figure>
	  <title>Radio with Component Cutouts and Default Material Properties</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <para>
	Note the hole for the antenna in the top of the case and the hole for the
	talk button on the side of the case. We will now fill these holes with
	their respective components.
      </para>
      <note>
	<para>
	  Precedence Review
	</para>
	<para>
	  The order in which these primitives were unioned and subtracted is    
	  important. We unioned in spkr. s last so that all the subtractions    
	  would apply to body.s. The rules of precedence for Boolean operators  
	  indicate that subtraction and intersection have a higher priority     
	  than union (meaning that they are performed first).                   
	</para>
	<para>
	  Although the following operation is not in proper MGED syntax, it     
	  does illustrate the implied parentheses that precede and follow the   
	  union operators in our last command:                                  
	
	  <command>r case.r u (body.s - cavity.s - ant.s - knob.s - btn.s) u (spkr.s)[Enter] </command>
	  
	  Optionally, we could've unioned in spkr.s before body.s as follows:   
	  
	  <command>r case.r u spkr.s u body.s - cavity.s - ant.s - knob.s - btn.s[Enter]</command> 
	</para>
	<para>
	  Let's consider, however, what would have happened if we had done the  
	  following:                                                            
	  
	  <command>r case.r u body.s u spkr.s - cavity.s - ant.s - knob.s - btn.s[Enter]</command> 
                                                                          
	  In this last case, operator precedence would have caused the program  
	  to subtract cavity.s, ant.s, knob.s, and btn.s from spkr.s. Nothing   
	  would have been subtracted from body.s. Therefore, the holes in the   
	  case would not have been created.                                     
	</para>
	<para>
	  Subtracting cavity.s, ant.s, knobs, and btn.s from spkr.s would have  
	  produced no apparent effect because they do not overlap the volume of 
	  spkr.s.                                                               
	</para>
      </note>
    </sect1>
    <sect1>
      <title>The Other Regions</title>
      <para>
	Making the talk button is simpler than making the case. The button
	consists of the union of two primitive shapes. To make them into a region,
	type
	
	<command>r button.r u btn.s u btn2.s[Enter]</command>
      </para>
      <para>
	The volume knob and antenna are even simpler. They are single primitive
	shapes that can be made into regions by typing
	
	<command>r knob.r u knob.s[Enter]</command>
	
	<command>r ant.r u ant.s[Enter]</command>
      </para>
    </sect1>
    <sect1>
      <title>Gathering the Regions into an Assembly Combination</title>
      <para>
	Now let's take all of the regions we have made so far and gather them into
	an assembly (or group) combination called radio.c so that we can keep all
	of these parts together. There are several ways to do this. One way would
	be to use a similar method to the one we used to make the regions:
	
	<command>comb radio.c u case.r u button.r u knob.r u ant.r[Enter]</command>
      </para>
      <para>
	A shortcut, however, would be to use the g (group) command as follows:
	
	<command>g radio.c case.r button.r knob.r ant.r[Enter]</command>
	
	Unlike the comb command, the g command assumes that all of the items
	specified will be unioned together, and so no Boolean operators need to be
	specified.
      </para>
      <para>
	A final improvement would include using the database name wildcard *.r to
	quickly and easily specify all of the regions in the database:
	
	<command>g radio.c *.r[Enter]</command>
	
	If we now tree radio.c, we should get the following output in the Command
	Window.
	<literallayout>
   radio.c/

   u case.r/R

   u body.s

   - cavity.s

   - ant.s

   - knob.s

   - btn.s

   u spkr.s

   u button.r/R

   u btn.s

   u btn2.s

   u knob.r/R

   u knob.s

   u ant.r/R

   u ant.s
	</literallayout>
      </para>
    </sect1>
    <sect1>
      <title>Assigning Material Properties to the Regions</title>
      <para>
	Thus far, the objects we have created have no material properties other
	than the gray plastic that MGED assigns by default to any object without
	assigned material values. Now let's improve our design by assigning other
	material properties to the components.
      </para>
      <para>
	We'll give the antenna a realistic look by opening the Combination Editor,
	choosing ant.r from the drop-down Name menu, selecting mirror  from the
	drop-down  Shader menu, and clicking on Apply.
      </para>
      <para>
	We'll let the other components remain with the default plastic, but we'll
	assign them different colors. With the Combination Editor still open,
	select case.r from the drop-down Name menu, select the magenta option from
	the drop-down Color  menu, and then click Apply. Use the same method to
	assign the  volume control knob (knob.r) a blue color. For the talk button
	(button.r), let's keep it gray by leaving the default values in place. The
	design should appear similar to the following when raytraced in Underlay
	mode:
	
	<figure>
	  <title>Radio with Material Properties Assigned</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <para> 
	As we look at our radio now, we can see that the antenna looks a little
	bit like a straw. In reality, it should have a small cap on the end so
	that we can raise and lower the antenna. We can approximate this shape by
	creating an ellipsoid (which we'll call ant2.s) and unioning it in with
	the rest of the antenna as follows:
	
	<command>in ant2.s ell1 2 2 94 0 0 1 3[Enter]</command>
	
	<command>r ant.r u ant2.s[Enter]</command>
      </para>
    </sect1>
    <sect1>
      <title>Adding Internal Components</title>
      <para>
	Our radio is looking more and more realistic; however, it is still just a
	hollow shell. Let's further improve it by making a circuit board to go
	inside the case. To do this, type:
	
	<command>in board.s rpp 3 4 1 31 1 47[Enter]</command>
	
	<command>r board.r u board.s[Enter]</command>
      </para>
      <para>
	Let's give the board a green semi-shiny color. The easiest way to do this
	is via the Combination Editor, but this time let's use the Command Line
	approach. Type:

	<command>mater board.r "plastic sh=4" 0 198 0 1[Enter]</command>
	
	Diagrammed, this command says to:
	<informaltable>
	  <tgroup cols='5'>
	    <tbody>
	      <row>
		<entry>mater</entry>
		<entry>board.r</entry>
		<entry>"plastic sh=4"</entry>
		<entry>0 198 0</entry>
		<entry>1</entry>
	      </row>
	      <row>
		<entry>Assign material properties to</entry>
		<entry>the region called board.r.</entry>
		<entry>Apply the plastic shader with a shininess of 4</entry>
		<entry>Give it a green color</entry>
		<entry>Inherit color material type</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
      <para>
	Finally, we'll include the board with the rest of the components in
	radio.c as follows:
	
	<command>g radio.c board.r[Enter]</command>
	
	Our radio should now look like the following:
	
	<figure>
	  <title>Wireframe Radio with Circuit Board Added</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>

	In addition, the tree for radio.c should now look as follows:
	<literallayout>
   radio.c/

   u case.r/R

   u body.s

   - cavity.s

   - ant.s

   - knob.s

   - btn.s

   u spkr.s

   u button.r/R

   u btn.s

   u btn2.s

   u knob.r/R

   u knob.s

   u ant.r/R

   u ant.s

   u ant2.s

   u board.r/R

   u board.s
	</literallayout>
      </para>
    </sect1>
    <sect1>
      <title>Making Specialty Models of the Radio</title>
      <para>
	Now, what would happen to the circuit board if we were to raytrace the
	radio at this point? It would disappear because it lies within the case.
	So how can we make the circuit board visible outside of the case?
      </para>
      <para>
	There are two common ways to do this: a transparent view and a cutaway
	view. Each method has its advantages and disadvantages. With the
	transparent view, the Boolean operations remain unchanged, but some of the
	material properties of the "outside shell" are altered to better view
	interior parts of the model. With the cutaway view, the material
	properties remain unchanged, but some of the Boolean operations are
	altered to remove parts of the model that are obstructing our view of
	other parts. We will try both ways to view the inside of our radio.
      </para>
      <para>
	Different Approaches to Creating Specialty Models
      </para>
      <para>
	An important point to note here is that the transparent and cutaway views
	are specialty models. They are similar in nature to items a manufacturer
	might make for special purposes. For example, an automobile manufacturer
	makes cars for everyday use, but also makes modified versions for display
	at certain events. The body panels might be replaced with a transparent
	material or be partially cut away to reveal interior components.
      </para>
      <para>
	Good modeling practice follows the same pattern. The actual model of an
	item should not have to be changed in order to create a specialty view of
	it. Instead, a modified version of the item should be created. Thus, the
	modeler will not have to worry about remembering to return the model to
	the original condition after its special-purpose use, and the modeler can
	also retain the "display model" for future use.
      </para>
      <para>
	There are two common approaches to making these specialty models: First,
	the modeler can copy the original and replace components with modified
	versions. Second, the modeler can create new, unique parts from scratch
	and construct the modified item. The method chosen is a matter of personal
	choice and is usually determined by the extent of the modifications being
	done and the complexity of the original object.
      </para>
      <sect2>
	<title>Transparent View</title>
	<para>
	  Making a specialty radio with a transparent case would probably be the
	  easiest way to view the circuit board inside. All we have to do is make a
	  copy of our present radio case and modify its material properties. We'll
	  call the specialty case case_clear.r. Type
	  
	  <command>cp case.r case_clear.r[Enter]</command>
	  
	  We can now use the Combination Editor to set the material properties on
	  this case without affecting the "master" design of the radio. When this
	  has been done, we can combine this modified case with the other unchanged
	  radio components and group them as a new specialty radio named
	  radio_clear.c.
	</para>
	<para>
	  To set the material properties of case_clear.r, choose plastic from the
	  drop-down menu to the right of the Shader entry box in the Combination
	  Editor. (Although this is the shader that is used by default, we want to
	  explicitly select it in order to change one of its values.) Now change the
	  Transparency of the case to a value of .8. Apply the change and close the
	  Combination Editor.
	</para>
	<para>
	  Finally, create the specialty radio combination by typing:
	  
	  <command>g radio_clear.c case_clear.r button.r knob.r ant.r board.r[Enter]</command>
	  
	  and then Blast the display with
	  
	  <command>B radio_clear.c[Enter]</command>
	</para>
	<para>
	  Now raytrace your design to view the resulting effect. The new transparent
	  case should appear similar to the following:
	  <figure>
	    <title>Transparent View of the Radio</title>
	    <screenshot>
	      <graphic fileref=".png"/>
	    </screenshot>
	  </figure>
	</para>
	<para>
	  As shown in the following tree diagram, the structure of this specialty
	  radio_clear.c is not much different than that of the regular radio.c. The
	  only difference is that case.c has been replaced with case_clear.c.
	  <literallayout>
   radio_clear.c/

   u case_clear.r/R

   u body.s

   - cavity.s

   - ant.s

   - knob.s

   - btn.s

   u spkr.s

   u button.r/R

   u btn.s

   u btn2.s

   u knob.r/R

   u knob.s

   u ant.r/R

   u ant.s

   u ant2.s

   u board.r/R

   u board.s
	  </literallayout>
	</para>
	<note>
	  <para>
	    Notice in the preceding figure that the color chosen for the          
	    transparent case does influence the appearance of the internal        
	    objects. Although we made the circuit board green, the filter effect  
	    of the transparent magenta case-which allows no green light to enter  
	    or exit the case-causes the board to appear to be dark purple. This   
	    is okay in our situation. However, if accuracy in color is important  
	    in a model, the modeler should remember to select a neutral color     
	    (such as white or light gray) for the transparent object.             
	  </para>
	</note>
      </sect2>
      <sect2>
	<title>Cutaway View</title>
	<para>
	  Another way we can make the interior components of the radio visible is to
	  create a cutaway view. Although it is a little more complex to make than
	  the transparent view was, the cutaway view offers a particularly
	  interesting way to view geometry.
	</para>
	<para>
	There are several ways to make the cutaway view. Probably the easiest way
	is to use the "chainsaw" method to cut off part of the radio and reveal
	what is inside.
	</para>
	<para>
	  To do this, create an arb8 called cutaway.s, which will be used to cut off
	  the front corner of the radio. Because this is a cutting shape (i.e., it
	  is simply used to erase a portion of another shape and will not actually
	  be viewed), the dimensions of the arb8 are not critical. The only concern
	  is that cutaway.s be as tall as the case so that it completely removes a
	  corner from it.
	</para>
	<para>
	  Use the Shift Grips and multiple views (especially the Top view) to align
	  cutaway.s so that it angles diagonally across the top of the radio (as
	  shown in the following wireframe representation). When you've aligned the
	  shape the way you want it, create the following radio_cutaway.c
	  combination that unions in radio.c and subtracts out the shape (cutaway.s)
	  that is covering what you want to see (board.r):
	  
	  <command>comb radio_cutaway.c u radio.c - cutaway.s[Enter]</command>
  
	  <figure>
	    <title>Multipane View of Cutting Primitive</title>
	    <screenshot>
	      <graphic fileref=".png"/>
	    </screenshot>
	  </figure>
	</para>
	<para>
	  Blast the radio_cutaway.c combination onto the display and raytrace.
	  Depending on how your arb8 intersected the radio, the cutaway should look
	  similar to the following:
   
	  <figure>
	    <title>Cutaway View of Radio with Circuit Board Cut Off</title>
	    <screenshot>
	      <graphic fileref=".png"/>
	    </screenshot>
	  </figure>
	</para>
	<para>
	  Notice in the preceding figures that cutaway.s removes everything it
	  overlaps (including part of the circuit board). This is okay if we just
	  want to see inside the case. However, if we want to see all of the circuit
	  board and any other component overlapped by cutaway.s (e.g., button.r), we
	  would have to adjust our Boolean operations a little so that the cutaway
	  is subtracted only from our case.
	</para>
	<para>
	  To do this, we basically have two options: (1) we could move cutaway.s in
	  the structure so that it is subtracted from only case.r, or (2) we could
	  move cutaway.s in the structure so that it is subtracted from both body.s
	  and spkr.s, the two components that make up case.r. While both of these
	  options would produce the same effect, the first method requires just one
	  subtraction, whereas the second method potentially provides more control
	  by having the user select the individual components that will subtract out
	  the cutting shape.
	</para>
	<para>
	  Take a minute and compare the following trees for the cutaways we have
	  discussed so far. Especially note the position of cutaway.s in the
	  different structures. Also, note that when cutaway.s was subtracted from a
	  particular region or combination, the name of that region or combination
	  was changed. The reasoning behind this goes back to our original
	  discussion of specialty models. Remember that our purpose is to create a
	  new special-purpose model, not change the existing model. So, we must
	  change the name of any region or combination that contains any modified
	  components or structures. If we don't, the master model will also be
	  changed.
	</para>
	<para>*****Note - add figures showing tree structure - need to be redone*****</para>
      </sect2>
    </sect1>
    <sect1>
      <title>Redefining the Structure of the Radio</title>
      <para>
	As shapes are added in a design, the modeler often finds that the
	structure or association of components needs to change. Thus, we should
	pause at this point and consider how our radio is structured. While there
	are many ways to structure a model, two common modeling categories are
	location and functionality. For our radio, we have so far grouped
	everything together under the general category of Radio, as shown in the
	following:

  	<figure>
	  <title>Current Radio Structure</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
       </para>
       <para>
	 If we wanted to categorize our components according to location, however,
	 we might structure the model as follows:
	 
	 <figure>
	   <title>Location-Based Structure of Radio</title>
	   <screenshot>
	     <graphic fileref=".png"/>
	   </screenshot>
	 </figure>
       </para>
       <para>
	 If we wanted to define our components according to functionality, we might
	 structure the model another way. For instance, to repair an actual radio,
	 we would open the case, take out the circuit board, fix it, and put it
	 back in. When taking out the board, however, the knob and button would
	 probably be attached to it in some way, and so they too would need to come
	 out. Accordingly, our structure should be changed as shown in the
	 following diagram to associate the knob and button with the circuit board.
	 
	 <figure>
	   <title>Function-Based Structure of Radio</title>
	   <screenshot>
	     <graphic fileref=".png"/>
	   </screenshot>
	 </figure>
       </para>
       <para>
	 To accomplish this restructuring according to functionality, create an
	 assembly called electronics.c to hold these components together. Type:
	 
	 <command>g electronics.c board.r knob.r button.r[Enter]</command>
	 
	 Of course, we now need to remove board.r, knob.r, and button.r from the
	 radio.c assembly so that when electronics.c is added to the radio.c
	 assembly, we won't have the knob and button included twice in the model.
	 To do this, use the rm (remove) command:
	 
	 <command>rm radio.c board.r knob.r button.r[Enter]</command>
	 
	 and then union in the electronics assembly:
	 
	 <command>g radio.c electronics.c[Enter]</command>
       </para>
       <para>
	 Now the tree for radio.c should appear as follows:
	 <literallayout>
   radio.c/

   u case.r/R

   u body.s

   - cavity.s

   - ant.s

   - knob.s

   - btn.s

   u spkr.s

   u ant.r/R

   u ant.s

   u ant2.s

   u electronics.c/

   u board.r/R

   u board.s

   u knob.r/R

   u knob.s

   u button.r/R

   u btn.s

   u btn2.s
	 </literallayout>
       </para>
       <para>
	 Now let's remake our cutaway view. This time, let's do what we discussed
	 earlier and make the cutaway remove material from only the case, showing
	 all the other components.
       </para>
       <para>
	 First, we need to get rid of the old radio_cutaway.c, which was based on
	 our previous structure. To do this, type
	 
	 <command>kill radio_cutaway.c[Enter]</command>
	 
	 and then remake the combination by typing
	 
	 <command>comb radio_cutaway.c u case.r - cutaway.s u electronics.c u ant.r[Enter]</command>
	 
	 Now when we Blast the display and raytrace radio_cutaway.c, we should see
	 the following:
	 <figure>
	   <title>View of Radio with Just the Case Cut Away</title>
	   <screenshot>
	     <graphic fileref=".png"/>
	   </screenshot>
	 </figure>
       </para>
    </sect1>
    <sect1>
      <title>Review</title>
      <para>
	In this lesson, you:
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Made the shapes of the walkie-talkie radio into regions.</para>
	  </listitem>
	  <listitem>
	    <para>Gathered the regions into an assembly combination.</para>
	  </listitem>
	  <listitem>
	    <para>Assigned material properties to the regions.</para>
	  </listitem>
	  <listitem>
	    <para>Added internal components to the radio.</para>
	  </listitem>
	  <listitem>
	    <para>Created specialty models of the radio.</para>
	  </listitem>
	  <listitem>
	    <para>Redefined the structure of the radio.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter>


<appendix label="A">
  <title>MGED Commands</title>
  <sect1>
    <title>MGED User Commands</title>

     <informaltable>
       <tgroup cols='5'>
	 <tbody>
	   <row>
	     <entry>%</entry>
	     <entry>3ptarb</entry>
	     <entry>?</entry>
	     <entry>?devel</entry>
	     <entry>?lib</entry>
	   </row>
	   <row>
	     <entry>B</entry>
	     <entry>E</entry>
	     <entry>M</entry>
	     <entry>Z</entry>
	     <entry>adc</entry>
	   </row>
	   <row>
	     <entry>ae</entry>
	     <entry>analyze</entry>
	     <entry>animate</entry>
	     <entry>apropos</entry>
	     <entry>aproposdevel</entry>
	   </row>
	   <row>
	     <entry>aproposlib</entry>
	     <entry>arb</entry>
	     <entry>arced</entry>
	     <entry>area</entry>
	     <entry>arot</entry>
	   </row>
	   <row>
	     <entry>attach</entry>
	     <entry>bev</entry>
	     <entry>c</entry>
	     <entry>cat</entry>
	     <entry>center</entry>
	   </row>
	   <row>
	     <entry>color</entry>
	     <entry>comb</entry>
	     <entry>comb_color</entry>
	     <entry>copyeval</entry>
	     <entry>copymat</entry>
	   </row>
	   <row>
	     <entry>cp</entry>
	     <entry>cpi</entry>
	     <entry>d</entry>
	     <entry>dall</entry>
	     <entry>db</entry>
	   </row>
	   <row>
	     <entry>db_glob</entry>
	     <entry>dbconcat</entry>
	     <entry>debugbu</entry>
	     <entry>debugdir</entry>
	     <entry>debuglib</entry>
	   </row>
	   <row>
	     <entry>debugmem</entry>
	     <entry>debugnmg</entry>
	     <entry>decompose</entry>
	     <entry>delay</entry>
	     <entry>dm</entry>
	   </row>
	   <row>
	     <entry>draw</entry>
	     <entry>dup</entry>
	     <entry>e</entry>
	     <entry>eac</entry>
	     <entry>echo</entry>
	   </row>
	   <row>
	     <entry>edcodes</entry>
	     <entry>edcolor</entry>
	     <entry>edcomb</entry>
	     <entry>edgedir</entry>
	     <entry>edmater</entry>
	   </row>
	   <row>
	     <entry>eqn</entry>
	     <entry>erase</entry>
	     <entry>erase_all</entry>
	     <entry>ev</entry>
	     <entry>exit</entry>
	   </row>
	   <row>
	     <entry>expand</entry>
	     <entry>extrude</entry>
	     <entry>eye_pt</entry>
	     <entry>e_muves</entry>
	     <entry>facedef</entry>
	   </row>
	   <row>
	     <entry>facetize</entry>
	     <entry>find</entry>
	     <entry>fracture</entry>
	     <entry>g</entry>
	     <entry>garbage_collect</entry>
	   </row>
	   <row>
	     <entry>gui</entry>
	     <entry>help</entry>
	     <entry>helpdevel</entry>
	     <entry>helplib</entry>
	     <entry>history</entry>
	   </row>
	   <row>
	     <entry>i</entry>
	     <entry>idents</entry>
	     <entry>ill</entry>
	     <entry>in</entry>
	     <entry>inside</entry>
	   </row>
	   <row>
	     <entry>item</entry>
	     <entry>joint</entry>
	     <entry>journal</entry>
	     <entry>keep</entry>
	     <entry>keypoint</entry>
	   </row>
	   <row>
	     <entry>kill</entry>
	     <entry>killall</entry>
	     <entry>killtree</entry>
	     <entry>knob</entry>
	     <entry>l</entry>
	   </row>
	   <row>
	     <entry>labelvert</entry>
	     <entry>listeval</entry>
	     <entry>loadtk</entry>
	     <entry>lookat</entry>
	     <entry>ls</entry>
	   </row>
	   <row>
	     <entry>l_muves</entry>
	     <entry>make</entry>
	     <entry>make_bb</entry>
	     <entry>mater</entry>
	     <entry>matpick</entry>
	   </row>
	   <row>
	     <entry>memprint</entry>
	     <entry>mirface</entry>
	     <entry>mirror</entry>
	     <entry>mrot</entry>
	     <entry>mv</entry>
	   </row>
	   <row>
	     <entry>mvall</entry>
	     <entry>nirt</entry>
	     <entry>nmg_collapse</entry>
	     <entry>nmg_simplify</entry>
	     <entry>oed</entry>
	   </row>
	   <row>
	     <entry>opendb</entry>
	     <entry>orientation</entry>
	     <entry>orot</entry>
	     <entry>oscale</entry>
	     <entry>overlay</entry>
	   </row>
	   <row>
	     <entry>p</entry>
	     <entry>pathlist</entry>
	     <entry>paths</entry>
	     <entry>permute</entry>
	     <entry>pl</entry>
	   </row>
	   <row>
	     <entry>plot</entry>
	     <entry>polyb</entry>
	     <entry>pov</entry>
	     <entry>prcolor</entry>
	     <entry>prefix</entry>
	   </row>
	   <row>
	     <entry>press</entry>
	     <entry>preview</entry>
	     <entry>prj_add</entry>
	     <entry>ps</entry>
	     <entry>push</entry>
	   </row>
	   <row>
	     <entry>putmat</entry>
	     <entry>q</entry>
	     <entry>qorot</entry>
	     <entry>qray</entry>
	     <entry>query_ray</entry>
	   </row>
	   <row>
	     <entry>quit</entry>
	     <entry>qvrot</entry>
	     <entry>r</entry>
	     <entry>rcodes</entry>
	     <entry>read_muves</entry>
	   </row>
	   <row>
	     <entry>red</entry>
	     <entry>redraw_vlist</entry>
	     <entry>refresh</entry>
	     <entry>regdebug</entry>
	     <entry>regdef</entry>
	   </row>
	   <row>
	     <entry>regions</entry>
	     <entry>release</entry>
	     <entry>rfarb</entry>
	     <entry>rm</entry>
	     <entry>rmater</entry>
	   </row>
	   <row>
	     <entry>rmats</entry>
	     <entry>rot</entry>
	     <entry>rotobj</entry>
	     <entry>rrt</entry>
	     <entry>rt</entry>
	   </row>
	   <row>
	     <entry>rtcheck</entry>
	     <entry>savekey</entry>
	     <entry>saveview</entry>
	     <entry>sca</entry>
	     <entry>sed</entry>
	   </row>
	   <row>
	     <entry>setview</entry>
	     <entry>shader</entry>
	     <entry>shells</entry>
	     <entry>showmats</entry>
	     <entry>size</entry>
	   </row>
	   <row>
	     <entry>solids</entry>
	     <entry>status</entry>
	     <entry>summary</entry>
	     <entry>sv</entry>
	     <entry>sync</entry>
	   </row>
	   <row>
	     <entry>t</entry>
	     <entry>ted</entry>
	     <entry>title</entry>
	     <entry>tol</entry>
	     <entry>tops</entry>
	   </row>
	   <row>
	     <entry>tra</entry>
	     <entry>track</entry>
	     <entry>translate</entry>
	     <entry>tree</entry>
	     <entry>t_muves</entry>
	   </row>
	   <row>
	     <entry>units</entry>
	     <entry>vars</entry>
	     <entry>vdraw</entry>
	     <entry>view</entry>
	     <entry>viewsize</entry>
	   </row>

	   <row>
	     <entry>vnirt</entry>
	     <entry>vquery_ray</entry>
	     <entry>vrmgr</entry>
	     <entry>vrot</entry>
	     <entry>wcodes</entry>
	   </row>
	   <row>
	     <entry>whatid</entry>
	     <entry>which_shader</entry>
	     <entry>whichair</entry>
	     <entry>whichid</entry>
	     <entry>who</entry>
	   </row>
	   <row>
	     <entry>wmater</entry>
	     <entry>x</entry>
	     <entry>xpush</entry>
	     <entry>zoom</entry>
	     <entry></entry>
	   </row>
	 </tbody>
       </tgroup>
     </informaltable>
   </sect1>
 </appendix>


</book>